package lingo

import (
	"fmt"
	"reflect"
	"strings"
	"regexp"
)

// Operation
type Operation interface {
	Expression
	Operator() Operator
	Arg(idx int) Expression
	Args() []Expression
}

//Â NewSimpleOperation
func NewSet[T any](args ...TypedExpression[T]) TypedExpression[T] {
	var result TypedExpression[T]
	for _, arg := range args {
		result = NewSimpleOperation[T](OpSet, result, arg)
	}
	return result
}
func NewSimpleOperation[T any](op Operator, args...Expression) SimpleOperation[T] {
	return SimpleOperation[T]{
		op: op,
		args: args,
	}
}
type SimpleOperation[T any] struct {
	op Operator
	args []Expression
}
func (o SimpleOperation[T]) Type() reflect.Type { return o.op.Type() }
func (o SimpleOperation[T]) String() string { return VisitWithDefaultToStringBuilder(o) }
func (o SimpleOperation[T]) Operator() Operator { return o.op }
func (o SimpleOperation[T]) Args() []Expression { return o.args }
func (o SimpleOperation[T]) Arg(idx int) Expression { return o.arg(idx) }
func (o SimpleOperation[T]) arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

// NewPredicateOperation
func NewPredicateOperation(op Operator, args...Expression) PredicateOperation {
	return PredicateOperation(NewSimpleOperation[bool](op, args...))
}
type PredicateOperation SimpleOperation[bool]
func (o PredicateOperation) Type() reflect.Type { return o.Type() }
func (o PredicateOperation) String() string { return VisitWithDefaultToStringBuilder(o) }
func (o PredicateOperation) Not() PredicateExpression { return NewPredicateOperation(OpNot, o) }
func (o PredicateOperation) Operator() Operator { return o.op }
func (o PredicateOperation) Args() []Expression { return o.args }
func (o PredicateOperation) Arg(idx int) Expression { 
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}


// BooleanOperations
func NewOpAnd(l, r Expression) BooleanExpression { return NewBooleanOperation(OpAnd, l, r) }
func NewOpNot(e Expression) BooleanExpression { return NewBooleanOperation(OpNot, e) }
func NewOpOr(l, r Expression) BooleanExpression { return NewBooleanOperation(OpOr, l, r) }
func NewIsNull(e Expression) BooleanExpression { return NewBooleanOperation(OpIsNull, e) }
func NewIsNotNull(e Expression) BooleanExpression { return NewBooleanOperation(OpIsNotNull, e) }
func NewOpEqual(l, r Expression) BooleanExpression { return NewBooleanOperation(OpEqual, l, r) }
func NewOpGreaterThan(l, r Expression) BooleanExpression { return NewBooleanOperation(OpGreaterThan, l, r) }
func NewOpLessThan(l, r Expression) BooleanExpression { return NewBooleanOperation(OpLessThan, l, r) }
func NewOpGreaterThanOrEqual(l, r Expression) BooleanExpression { return NewBooleanOperation(OpGreaterThanOrEqual, l, r) }
func NewOpLessThanOrEqual(l, r Expression) BooleanExpression { return NewBooleanOperation(OpLessThanOrEqual, l, r) }
func NewOpBetween(p, l, r Expression) BooleanExpression { return NewBooleanOperation(OpBetween, p, l, r) }
func NewOpNotBetween(p, l, r Expression) BooleanExpression { return NewBooleanOperation(OpNotBetween, p, l, r) }

// NewBooleanOperation
func NewBooleanOperation(op Operator, args ...Expression) BooleanOperation {
	return BooleanOperation{
		PredicateOperation: NewPredicateOperation(op, args...),
	}
}
type BooleanOperation struct {
	PredicateOperation
}
// -- Expression
func (o BooleanOperation) Type() reflect.Type { return o.PredicateOperation.Type() }
func (o BooleanOperation) String() string { return VisitWithDefaultToStringBuilder(o) }

// -- BooleanExpression
func (o BooleanOperation) As(alias string) BooleanExpression { 
	return o.AsPath(NewSimplePathForVariable[bool](false, alias))
}
func (o BooleanOperation) AsPath(p TypedPath[bool]) BooleanExpression { 
	return NewBooleanOperation(OpAlias, o, p) 
}
func (o BooleanOperation) And(e PredicateExpression) BooleanExpression { 
	return NewOpAnd(o, e)
}
func (o BooleanOperation) Not() BooleanExpression { 
	return NewOpNot(o)
}
func (o BooleanOperation) Or(e PredicateExpression) BooleanExpression {
	return NewOpOr(o, e)
}
func (o BooleanOperation) IsTrue() BooleanExpression { 
	return o.EqValue(true) 
}
func (o BooleanOperation) IsFalse() BooleanExpression { 
	return o.EqValue(false) 
}
func (o BooleanOperation) EqValue(v bool) BooleanExpression { 
	return o.Eq(NewSimpleConstant[bool](v))
}
func (o BooleanOperation) Eq(e TypedExpression[bool]) BooleanExpression { 
	return NewOpEqual(o, e) 
}

// NewComparableOperation creates a ComparableExpression of the specified type
func NewComparableOperation[T comparable](op Operator, args...Expression) ComparableOperation[T] {
	return ComparableOperation[T]{
		mixin: NewSimpleOperation[T](op, args...),
	}
}
// ComparableOperation is a basic ComparableExpression
type ComparableOperation[T comparable] struct {
	mixin SimpleOperation[T]
}
// -- Expression
func (o ComparableOperation[T]) Type() reflect.Type { return o.mixin.Type() }
func (o ComparableOperation[T]) String() string { return VisitWithDefaultToStringBuilder(o) }
// -- AnyComparableExpression
func (o ComparableOperation[T]) Asc() Order[T] {
	return NewOrderBy[T](OrderAsc, o)
}
func (o ComparableOperation[T]) Desc() Order[T] {
	return NewOrderBy[T](OrderDesc, o)
}
// -- ComparableExpression
func (o ComparableOperation[T]) BetweenValues(l, r T) BooleanExpression {
	return o.Between(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (o ComparableOperation[T]) Between(l, r TypedExpression[T]) BooleanExpression {
	return NewOpBetween(o, l, r)
}
func (o ComparableOperation[T]) NotBetweenValues(l, r T) BooleanExpression {
	return o.NotBetween(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (o ComparableOperation[T]) NotBetween(l, r TypedExpression[T]) BooleanExpression {
	return NewOpNotBetween(o, l, r)
}
func (o ComparableOperation[T]) GTValue(v T) BooleanExpression {
	return o.GT(NewSimpleConstant[T](v))
}
func (o ComparableOperation[T]) GT(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThan(o, e)
}
func (o ComparableOperation[T]) GTOrEqValue(v T) BooleanExpression {
	return o.GTOrEq(NewSimpleConstant[T](v))
}
func (o ComparableOperation[T]) GTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThanOrEqual(o, e)
}
func (o ComparableOperation[T]) LTValue(v T) BooleanExpression {
	return o.LT(NewSimpleConstant[T](v))
}
func (o ComparableOperation[T]) LT(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThan(o, e)
}
func (o ComparableOperation[T]) LTOrEqValue(v T) BooleanExpression {
	return o.LTOrEq(NewSimpleConstant[T](v))
}
func (o ComparableOperation[T]) LTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThanOrEqual(o, e)
}

// NewNumberOperation creates a NumberOperation of the specified numeric type N
func NewNumberOperation[N numeric](op Operator, args ...Expression) NumberOperation[N] {
	return NumberOperation[N]{
		mixin: NewSimpleOperation[N](op, args...),
	}
}
func CastToNumber[L comparable, N numeric](e LiteralExpression[L], numberType N) NumberExpression[N] {
	return NewNumberOperation[N](OpNumCast, e, NewSimpleConstant[N](numberType))
}
// NumberOperation is a basic NumberExpression of numeric type N
type NumberOperation[T numeric] struct {
	mixin TypedExpression[T]
}
// -- Expression
func (o NumberOperation[T]) Type() reflect.Type { return o.mixin.Type() }
func (o NumberOperation[T]) String() string { return VisitWithDefaultToStringBuilder(o) }
// -- LiteralExpression
func (o NumberOperation[T]) StringValue() StringExpression {
	return NewStringOperation(OpStringCast, o)
}
// -- AnyComparableExpression
func (o NumberOperation[T]) Asc() Order[T] {
	return NewOrderBy[T](OrderAsc, o)
}
func (o NumberOperation[T]) Desc() Order[T] {
	return NewOrderBy[T](OrderDesc, o)
}
// -- ComparableExpression
func (o NumberOperation[T]) BetweenValues(l, r T) BooleanExpression {
	return o.Between(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (o NumberOperation[T]) Between(l, r TypedExpression[T]) BooleanExpression {
	return NewOpBetween(o, l, r)
}
func (o NumberOperation[T]) NotBetweenValues(l, r T) BooleanExpression {
	return o.NotBetween(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (o NumberOperation[T]) NotBetween(l, r TypedExpression[T]) BooleanExpression {
	return NewOpNotBetween(o, l, r)
}
func (o NumberOperation[T]) GTValue(v T) BooleanExpression {
	return o.GT(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) GT(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThan(o, e)
}
func (o NumberOperation[T]) GTOrEqValue(v T) BooleanExpression {
	return o.GTOrEq(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) GTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThanOrEqual(o, e)
}
func (o NumberOperation[T]) LTValue(v T) BooleanExpression {
	return o.LT(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) LT(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThan(o, e)
}
func (o NumberOperation[T]) LTOrEqValue(v T) BooleanExpression {
	return o.LTOrEq(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) LTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThanOrEqual(o, e)
}
// -- NumberExpression
func (o NumberOperation[T]) Abs() NumberExpression[T] {
	return NewNumberOperation[T](OpAbs, o)
}
func (o NumberOperation[T]) AddValue(v T) NumberExpression[T] {
	return o.Add(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) Add(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpAddition, o, v)
}
func (o NumberOperation[T]) AsPath(p TypedPath[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpAlias, o, p)
}
func (o NumberOperation[T]) As(alias string) NumberExpression[T] {
	return o.AsPath(NewSimplePathForVariable[T](T(0), alias))
}
func (o NumberOperation[T]) Ceil() NumberExpression[T] {
	return NewNumberOperation[T](OpCeiling, o)
}
func (o NumberOperation[T]) DivideValue(v T) NumberExpression[T] {
	return o.Divide(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) Divide(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpDivision, o, v)
}
func (o NumberOperation[T]) EqValue(v T) BooleanExpression {
	return o.Eq(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) Eq(v TypedExpression[T]) BooleanExpression {
	return NewOpEqual(o, v)
}
func (o NumberOperation[T]) Floor() NumberExpression[T] {
	return NewNumberOperation[T](OpFloor, o)
}
func (o NumberOperation[T]) ModValue(v T) NumberExpression[T] {
	return o.Mod(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) Mod(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpModulo, o, v)
}
func (o NumberOperation[T]) MultiplyValue(v T) NumberExpression[T] {
	return o.Multiply(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) Multiply(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpMultiplication, o, v)
}
func (o NumberOperation[T]) Negate() NumberExpression[T] {
	return NewNumberOperation[T](OpNegate, o)
}
func (o NumberOperation[T]) Round() NumberExpression[T] {
	return NewNumberOperation[T](OpRound, o)
}
func (o NumberOperation[T]) Sqrt() NumberExpression[T] {
	return NewNumberOperation[T](OpSquareRoot, o)
}
func (o NumberOperation[T]) SubtractValue(v T) NumberExpression[T] {
	return o.Subtract(NewSimpleConstant[T](v))
}
func (o NumberOperation[T]) Subtract(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpSubtraction, o, v)
}
func (o NumberOperation[T]) InValues(v ...T) NumberExpression[T] {
	return o.In(NewSimpleConstant[[]T](v))
}
func (o NumberOperation[T]) In(v ...TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpIn, o, NewSet[T](v...))
}
func (o NumberOperation[T]) NotInValues(v ...T) NumberExpression[T] {
	return o.NotIn(NewSimpleConstant[[]T](v))
}
func (o NumberOperation[T]) NotIn(v ...TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpNotIn, o, NewSet[T](v...))
}

// NewStringOperation creates a StringOperation from one or more basic Expressions
func NewStringOperation(op Operator, args ...Expression) StringOperation {
	return StringOperation{
		mixin: NewSimpleOperation[string](op, args...),
	}
}
// StringOperation is a basic StringExpression
type StringOperation struct {
	mixin SimpleOperation[string]
}
// -- Expression
func (o StringOperation) Type() reflect.Type { return o.mixin.Type() }
func (o StringOperation) String() string { return VisitWithDefaultToStringBuilder(o) }
// -- AnyComparableExpression
func (o StringOperation) Asc() Order[string] {
	return NewOrderBy[string](OrderAsc, o)
}
func (o StringOperation) Desc() Order[string] {
	return NewOrderBy[string](OrderDesc, o)
}
// -- ComparableExpression
func (o StringOperation) BetweenValues(l, r string) BooleanExpression {
	return o.Between(NewSimpleConstant[string](l), NewSimpleConstant[string](r))
}
func (o StringOperation) Between(l, r TypedExpression[string]) BooleanExpression {
	return NewOpBetween(o, l, r)
}
func (o StringOperation) NotBetweenValues(l, r string) BooleanExpression {
	return o.NotBetween(NewSimpleConstant[string](l), NewSimpleConstant[string](r))
}
func (o StringOperation) NotBetween(l, r TypedExpression[string]) BooleanExpression {
	return NewOpNotBetween(o, l, r)
}
func (o StringOperation) GTValue(v string) BooleanExpression {
	return o.GT(NewSimpleConstant[string](v))
}
func (o StringOperation) GT(v TypedExpression[string]) BooleanExpression {
	return NewOpGreaterThan(o, v)
}
func (o StringOperation) GTOrEqValue(v string) BooleanExpression {
	return o.GTOrEq(NewSimpleConstant[string](v))
}
func (o StringOperation) GTOrEq(v TypedExpression[string]) BooleanExpression {
	return NewOpGreaterThanOrEqual(o, v)
}
func (o StringOperation) LTValue(v string) BooleanExpression {
	return o.LT(NewSimpleConstant[string](v))
}
func (o StringOperation) LT(v TypedExpression[string]) BooleanExpression {
	return NewOpLessThan(o, v)
}
func (o StringOperation) LTOrEqValue(v string) BooleanExpression {
	return o.LTOrEq(NewSimpleConstant[string](v))
}
func (o StringOperation) LTOrEq(v TypedExpression[string]) BooleanExpression {
	return NewOpLessThanOrEqual(o, v)
}
// -- LiteralExpression
func (o StringOperation) StringValue() StringExpression {
	return o
}
// -- StringExpression
func (o StringOperation) As(alias TypedPath[string]) StringExpression {
	return NewStringOperation(OpAlias, o, alias)
}
func (o StringOperation) Alias(alias string) StringExpression {
	return o.As(NewSimplePathForVariable[string]("", alias))
}
func (o StringOperation) AppendValue(v string) StringExpression {
	return o.Append(NewSimpleConstant[string](v))
}
func (o StringOperation) Append(v TypedExpression[string]) StringExpression {
	return NewStringOperation(OpStringConcat, o, v)
}
func (o StringOperation) CharAtValue(idx int) TypedExpression[rune] {
	return o.CharAt(NewSimpleConstant[int](idx))
}
func (o StringOperation) CharAt(idx TypedExpression[int]) TypedExpression[rune] {
	return NewStringOperation(OpCharAt, o, idx)
}
func (o StringOperation) ConcatValue(v string) StringExpression {
	return o.AppendValue(v)
}
func (o StringOperation) Concat(v TypedExpression[string]) StringExpression {
	return o.Append(v)
}
func (o StringOperation) ContainsValue(v string) BooleanExpression {
	return o.Contains(NewSimpleConstant[string](v))
}
func (o StringOperation) Contains(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringContains, o, v)
}
func (o StringOperation) ContainsFoldValue(v string) BooleanExpression {
	return o.ContainsFold(NewSimpleConstant[string](v))
}
func (o StringOperation) ContainsFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringContainsFold, o, v)
}
func (o StringOperation) EqualsFoldValue(v string) BooleanExpression {
	return o.EqualsFold(NewSimpleConstant[string](v))
}
func (o StringOperation) EqualsFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpEqualsFold, o, v)
}
func (o StringOperation) HasPrefixValue(v string) BooleanExpression {
	return o.HasPrefix(NewSimpleConstant[string](v))
}
func (o StringOperation) HasPrefix(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasPrefix, o, v)
}
func (o StringOperation) HasPrefixFoldValue(v string) BooleanExpression {
	return o.HasPrefixFold(NewSimpleConstant[string](v))
}
func (o StringOperation) HasPrefixFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasPrefixFold, o, v)
}
func (o StringOperation) HasSuffixValue(v string) BooleanExpression {
	return o.HasSuffix(NewSimpleConstant[string](v))
}
func (o StringOperation) HasSuffix(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasSuffix, o, v)
}
func (o StringOperation) HasSuffixFoldValue(v string) BooleanExpression {
	return o.HasSuffixFold(NewSimpleConstant[string](v))
}
func (o StringOperation) HasSuffixFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasSuffixFold, o, v)
}
func (o StringOperation) IndexOfValue(v string) NumberExpression[int] {
	return o.IndexOf(NewSimpleConstant[string](v))
}
func (o StringOperation) IndexOf(v TypedExpression[string]) NumberExpression[int] {
	return NewNumberOperation[int](OpIndexOf, o, v)
}
func (o StringOperation) IndexOfNValue(v string, n int) NumberExpression[int] {
	return o.IndexOfN(NewSimpleConstant[string](v), n)
}
func (o StringOperation) IndexOfN(v TypedExpression[string], n int) NumberExpression[int] {
	return NewNumberOperation[int](OpIndexOfN, o, v, NewSimpleConstant[int](n))
}
func (o StringOperation) IsEmpty() BooleanExpression {
	return NewBooleanOperation(OpStringIsEmpty, o)
}
func (o StringOperation) IsNotEmpty() BooleanExpression {
	return o.IsEmpty().Not()
}
func (o StringOperation) Len() NumberExpression[int] {
	return NewNumberOperation[int](OpStringLength, o)
}
func (o StringOperation) LikeValue(v string) BooleanExpression {
	return o.Like(NewSimpleConstant[string](v))
}
func (o StringOperation) Like(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringLike, o, v)
}
func (o StringOperation) LikeFoldValue(v string) BooleanExpression {
	return o.LikeFold(NewSimpleConstant[string](v))
}
func (o StringOperation) LikeFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringLikeFold, o, v)
}
func (o StringOperation) LikeEscapeValue(v string, escape rune) BooleanExpression {
	return o.LikeEscape(NewSimpleConstant[string](v), escape)
}
func (o StringOperation) LikeEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return NewBooleanOperation(OpStringLikeEscape, o, v, NewSimpleConstant[rune](escape))
}
func (o StringOperation) LikeFoldEscapeValue(v string, escape rune) BooleanExpression {
	return o.LikeFoldEscape(NewSimpleConstant[string](v), escape)
}
func (o StringOperation) LikeFoldEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return NewBooleanOperation(OpStringLikeFoldEscape, o, v, NewSimpleConstant[rune](escape))
}
func (o StringOperation) LocateValue(v string) NumberExpression[int] {
	return o.Locate(NewSimpleConstant[string](v))
}
func (o StringOperation) Locate(v TypedExpression[string]) NumberExpression[int] {
	return NewNumberOperation[int](OpStringLocate, v)
}
func (o StringOperation) LocateFromValues(v string, start int) NumberExpression[int] {
	return o.LocateFromValue(NewSimpleConstant[string](v), start)
}
func (o StringOperation) LocateFromValue(v TypedExpression[string], start int) NumberExpression[int] {
	return o.LocateFrom(v, NewSimpleConstant[int](start))
}
func (o StringOperation) LocateFrom(v TypedExpression[string], start TypedExpression[int]) NumberExpression[int] {
	return NewNumberOperation[int](OpStringLocate2, v, start)
}
func (o StringOperation) Lower() StringExpression {
	return NewStringOperation(OpStringLower, o)
}
func (o StringOperation) MatchesValue(regex regexp.Regexp) BooleanExpression {
	return o.Matches(NewSimpleConstant[string](regex.String()))
}
func (o StringOperation) Matches(regex TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringMatches, o, regex)
}
func (o StringOperation) NotEqFoldValue(v string) BooleanExpression {
	return o.NotEqFold(NewSimpleConstant[string](v))
}
func (o StringOperation) NotEqFold(v TypedExpression[string]) BooleanExpression {
	return o.EqualsFold(v).Not()
}
func (o StringOperation) NotLikeValue(v string) BooleanExpression {
	return o.NotLike(NewSimpleConstant[string](v))
}
func (o StringOperation) NotLike(v TypedExpression[string]) BooleanExpression {
	return o.Like(v).Not()
}
func (o StringOperation) NotLikeFoldValue(v string) BooleanExpression {
	return o.NotLikeFold(NewSimpleConstant[string](v))
}
func (o StringOperation) NotLikeFold(v TypedExpression[string]) BooleanExpression {
	return o.LikeFold(v).Not()
}
func (o StringOperation) NotLikeEscapeValue(v string, escape rune) BooleanExpression {
	return o.NotLikeEscape(NewSimpleConstant[string](v), escape)
}
func (o StringOperation) NotLikeEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return o.LikeEscape(v, escape).Not()
}
func (o StringOperation) NotLikeFoldEscapeValue(v string, escape rune) BooleanExpression {
	return o.NotLikeFoldEscape(NewSimpleConstant[string](v), escape)
}
func (o StringOperation) NotLikeFoldEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return o.LikeFoldEscape(v, escape).Not()
}
func (o StringOperation) PrependValue(v string) StringExpression {
	return o.Prepend(NewSimpleConstant[string](v))
}
func (o StringOperation) Prepend(v TypedExpression[string]) StringExpression {
	return NewStringOperation(OpStringConcat, o, v)
}
func (o StringOperation) SubstringStartValue(begin int) StringExpression {
	return o.SubstringStart(NewSimpleConstant[int](begin))
}
func (o StringOperation) SubstringStart(begin TypedExpression[int]) StringExpression {
	return NewStringOperation(OpStringSubstring, o, begin)
}
func (o StringOperation) SubstringStartValueEnd(begin int, end TypedExpression[int]) StringExpression {
	return o.SubstringStartEnd(NewSimpleConstant[int](begin), end)
}
func (o StringOperation) SubstringStartEndValue(begin TypedExpression[int], end int) StringExpression {
	return o.SubstringStartEnd(begin, NewSimpleConstant[int](end))
}
func (o StringOperation) SubstringStartAndEndValue(begin, end int) StringExpression {
	return o.SubstringStartEnd(NewSimpleConstant[int](begin), NewSimpleConstant[int](end))
}
func (o StringOperation) SubstringStartEnd(begin, end TypedExpression[int]) StringExpression {
	return NewStringOperation(OpStringSubstring2, o, begin, end)
}
func (o StringOperation) Trim() StringExpression {
	return NewStringOperation(OpStringTrim, o)
}
func (o StringOperation) Upper() StringExpression {
	return NewStringOperation(OpStringToUpper, o)
}










type Operator interface {
	Type() reflect.Type
}

type Category int

const (
	// CatUnknown is the default Category - used to denote an unset Category.
	CatUnknown Category = iota

	// CatArithmetic operators can perform arithmetical operations on numeric operands.
	CatArithmetic

	// CatAssignment operators assigns a QueryParam to a variable or of a column or field of a table.
	CatAssignment

	// CatBitwise operators perform bit manipulations between two numeric expressions.
	CatBitwise

	// CatComparison (or relational) operators are mathematical symbols which are used to compare two values.
	// The result of a comparison can be TRUE, FALSE, or UNKNOWN.
	CatComparison

	// CatLogical operators are those that are true or false. They return a true or false values to combine one or
	// more true or false values.
	CatLogical

	// CatSet operators merges two queries using different algorithms
	CatSet

	// CatString operators can combine two or more string data types into one expression
	CatString

	// CatNumeric operators can combine two or more numeric data types into one expression
	CatNumeric

	// CatUnary operators perform such an operation which contain only one expression.
	CatUnary

	// TODO - Update this name!!!
	// CatOthers just dont know what the heck to call this...
	CatOthers

	// CatLastCategory is the last entry in Category. Allows for iterating over Category.
	CatLastCategory
)

// Operators that belong to this Category
func (c Category) Operators() []Operator {
	ops := make([]Operator, len(categoryToOperators[c]))
	copy(ops, categoryToOperators[c])
	return ops
}

// Op a specific type of an Operation
type Op int

func (op Op) Type() reflect.Type {
	return reflect.TypeOf(op)
}

const (
	// OpUnknown is the default Operator - used to denote an unset Operator.
	OpUnknown Op = iota

	// CatArithmetic Operators

	OpAddition
	OpSubtraction
	OpMultiplication
	OpDivision
	OpModulo

	// CatAssignment Operators

	OpAssign
	OpAlias

	// CatBitwise Operators

	OpBitwiseAND
	OpBitwiseNOT
	OpBitwiseOR
	OpBitwiseXOR

	// CatComparison Operators

	OpIsNull
	OpIsNotNull
	OpEqual
	OpNotEqual
	OpLessThan
	OpLessThanOrEqual
	OpGreaterThan
	OpGreaterThanOrEqual

	// CatLogical Operators

	OpAnd
	OpOr
	OpNot
	OpIn
	OpNotIn
	OpBetween
	OpNotBetween
	OpAny
	OpAll
	OpSome
	OpExists

	// CatSet Operators

	OpSet
	OpList
	OpUnion
	OpExcept
	OpIntersect

	// CatString Operators

	OpStringCast
	OpStringConcat
	OpCharAt
	OpStringContains
	OpStringContainsFold
	OpEqualsFold
	OpHasPrefix
	OpHasPrefixFold
	OpHasSuffix
	OpHasSuffixFold
	OpIndexOf
	OpIndexOfN
	OpStringIsEmpty
	OpStringLength
	OpStringLike
	OpStringLikeFold
	OpStringLikeEscape
	OpStringLikeFoldEscape
	OpStringLocate
	OpStringLocate2
	OpStringLower
	OpStringMatches
	OpStringSubstring
	OpStringSubstring2
	OpStringTrim
	OpStringToUpper

	// CatMath Operators

	OpAbs
	OpCeiling
	OpFloor
	OpMax
	OpMin
	OpNumCast
	OpRound
	OpSquareRoot

	// CatUnary Operators

	OpSingleton
	OpNegate
	OpCurrentTimestamp

	// CatOthers Operators
	OpCount
	OpLike
	OpNotLike

	// OpLastOperator is the last entry in Operator list. Allows for iterating over Operator.
	OpLastOperation

	// Put aliases for Operator here to not affect OpLastOperator
	// Ex: OpNewName = OpOldName
)

// String serves as the name of the operator. It is a single SnakeCased ASCII word that is used in generating paths.
func (o Op) String() string {
	return operatorToString[o]
}

// Category of operations this Operator belongs to.
func (o Op) Category() Category {
	return operatorToCategory[o]
}

// This is used to ensure:
// - all categories have an operator
// - all operators have method strings
// - each operator only exists in one category
// Each Operator string must be a single SnakeCased ASCII word that is used in generating paths.
var _ = checkAllOpsInACategoryWithStrings(map[Category]map[Operator]string{
	CatUnknown: {
		OpUnknown: "Unknown",
	},
	CatArithmetic: {
		OpAddition:       "Addition",
		OpSubtraction:    "Subtraction",
		OpMultiplication: "Multiplication",
		OpDivision:       "Division",
		OpModulo:         "Modulo",
	},
	CatAssignment: {
		OpAssign: "Assign",
		OpAlias:  "Alias",
	},
	CatBitwise: {
		OpBitwiseAND: "BitwiseAND",
		OpBitwiseNOT: "BitwiseNOT",
		OpBitwiseOR:  "BitwiseOR",
		OpBitwiseXOR: "BitwiseXOR",
	},
	CatComparison: {
		OpIsNull:             "IsNull",
		OpIsNotNull:          "IsNotNull",
		OpEqual:              "Equal",
		OpNotEqual:           "NotEqual",
		OpLessThan:           "LessThan",
		OpLessThanOrEqual:    "LessThanOrEqual",
		OpGreaterThan:        "GreaterThan",
		OpGreaterThanOrEqual: "GreaterThanOrEqual",
	},
	CatLogical: {
		OpAnd:        "And",
		OpOr:         "Or",
		OpNot:        "Not",
		OpIn:         "In",
		OpNotIn:      "NotIn",
		OpBetween:    "Between",
		OpNotBetween: "NotBetween",
		OpAny:        "Any",
		OpAll:        "All",
		OpSome:       "Some",
		OpExists:     "Exists",
	},
	CatSet: {
		OpSet:       "Set",
		OpList:      "List",
		OpUnion:     "Union",
		OpExcept:    "Except",
		OpIntersect: "Intersect",
	},
	CatString: {
		OpStringCast:   "StringCast",
		OpStringConcat: "StringConcat",
		OpCharAt:       "CharAt",
		OpStringContains: "StringContains",
		OpStringContainsFold: "StringContainsFold",
		OpEqualsFold: "EqualsFold",
		OpHasPrefix: "HasPrefix",
		OpHasPrefixFold: "HasPrefixFold",
		OpHasSuffix: "HasSuffix",
		OpHasSuffixFold: "HasSuffixFold",
		OpIndexOf: "IndexOf",
		OpIndexOfN: "IndexOfN",
		OpStringIsEmpty: "StringIsEmpty",
		OpStringLength: "StringLength",
		OpStringLike: "StringLike",
		OpStringLikeFold: "StringLikeFold",
		OpStringLikeEscape: "StringLikeEscape",
		OpStringLikeFoldEscape: "StringLikeFoldEscape",
		OpStringLocate: "StringLocate",
		OpStringLocate2: "StringLocate2",
		OpStringLower: "StringLower",
		OpStringMatches: "StringMatches",
		OpStringSubstring: "StringSubstring",
		OpStringSubstring2: "StringSubstring2",
		OpStringTrim: "StringTrim",
		OpStringToUpper: "OpStringToUpper",
	},
	CatNumeric: {
		OpAbs:        "Abs",
		OpCeiling:    "Ceiling",
		OpFloor:      "Floor",
		OpMax:        "Max",
		OpMin:        "Min",
		OpNumCast:    "NumCast",
		OpRound:      "Round",
		OpSquareRoot: "SquareRoot",
	},
	CatUnary: {
		OpSingleton: "Singleton",
		OpNegate:    "Negate",
	},
	CatOthers: {
		OpCount:            "Count",
		OpLike:             "Like",
		OpNotLike:          "NotLike",
		OpCurrentTimestamp: "CurrentTimestamp",
	},
})

var operatorToString = make(map[Operator]string)
var operatorToCategory = make(map[Operator]Category)
var categoryToOperators = make(map[Category][]Operator)

func checkAllOpsInACategoryWithStrings(catToOps map[Category]map[Operator]string) map[Category]map[Operator]string {
	foundOps := make(map[Operator]Category)
	foundOpStrs := make(map[string]Category)

	var errMsgs []string
	for cat := CatUnknown; cat < CatLastCategory; cat++ {
		opsToStr, found := catToOps[cat]
		if !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Category %d is not in catToOps", cat))
			continue
		}

		for op, opStr := range opsToStr {
			// Check if this operation already exists / is in another category
			otherCat, alreadyHaveOp := foundOps[op]
			if alreadyHaveOp {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator %s is already in Category %d", opStr, otherCat))
				continue
			}
			foundOps[op] = cat

			// Check if this operation's string QueryParam already exists / is in another category
			otherCat, alreadyHaveOpStr := foundOpStrs[opStr]
			if alreadyHaveOpStr {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator string %s is already in Category %d", opStr, otherCat))
				continue
			}
			foundOpStrs[opStr] = cat

			categoryToOperators[cat] = append(categoryToOperators[cat], op)
			operatorToCategory[op] = cat
			operatorToString[op] = opStr
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}

	for op := OpUnknown; op < OpLastOperation; op++ {
		if _, found := foundOps[op]; !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Operator QueryParam %d was not found in any category", op))
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}
	return catToOps
}
