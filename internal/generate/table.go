package generate

import (
	"fmt"
	"io"
	"strings"
)

const HeaderCommentPrefix = "// Code generated by Lingo for "
const fmtTableHeaderComment = HeaderCommentPrefix + "table %s.%s - DO NOT EDIT\n\n"

const PkgLingo = "github.com/weworksandbox/lingo"
const PkgShortExpr = "expr"
const PkgExpr = PkgLingo + "/" + PkgShortExpr
const PkgSQL = PkgLingo + "/sql"

type TableInfo struct {
	Prefix      rune
	Name        string
	Schema      string
	Columns     []column
	ForeignKeys []ForeignKey
}

type TableGenerator struct {
	Prefix           string
	GeneratedComment string
	SchemaName       string
	DBName           string
	PackageName      string
	StructName       string
	Columns          []column
	Imports          []string
}

func NewTable(info TableInfo) (TableGenerator, error) {
	t := TableGenerator{
		Prefix:           string(info.Prefix),
		GeneratedComment: fmt.Sprintf(fmtTableHeaderComment, info.Schema, info.Name),
		SchemaName:       info.Schema,
		DBName:           info.Name,
		PackageName:      ToPackageName(info.Prefix, info.Name),
		StructName:       ToTableStruct(info.Prefix, info.Name),
		Columns:          info.Columns,
	}
	return t, nil
}

func (t TableGenerator) GenerateTable() (io.Reader, error) {
	defaultImports := []string{
		PkgLingo,
		PkgSQL,
	}
	t.Imports = determineImports(defaultImports, t.Columns)
	return FromTemplate(tableTemplate, t)
}

func (t TableGenerator) GenerateExported() (io.Reader, error) {
	t.Imports = determineImports([]string{}, t.Columns)
	return FromTemplate(exportedTemplate, t)
}

func determineImports(defaultImports []string, cols []column) []string {
	var thirdParty []string

	for _, col := range cols {
		pkg := col.PathType.Pkg()

		if containsString(defaultImports, pkg) || containsString(thirdParty, pkg) {
			continue
		}
		if strings.HasPrefix(pkg, PkgLingo) {
			defaultImports = append(defaultImports, pkg)
		} else {
			thirdParty = append(thirdParty, pkg)
		}
	}

	if len(thirdParty) > 0 {
		thirdParty = append(thirdParty, "")
	}
	return append(thirdParty, defaultImports...)
}

func containsString(strs []string, value string) bool {
	for _, str := range strs {
		if strings.EqualFold(str, value) {
			return true
		}
	}
	return false
}

var tableTemplate = createWithImports("table", tableTemplateString)

const tableTemplateString = `{{ .GeneratedComment }}

// +build !nolingo

package {{ .PackageName }}

{{ template "imports" .Imports }}

func As(alias string) {{.StructName}} {
	t := New()
	if alias != "" {
		t.alias = expr.Lit(alias)
	}
	return t
}

func New() {{.StructName}} {
	return {{.StructName}}{}
}

type {{.StructName}} struct {
	alias lingo.Expression
}

// lingo.Table Functions

func (t {{.StructName}}) GetTableName() string {
	return "{{.DBName}}"
}

func (t {{.StructName}}) GetColumns() []lingo.Expression {
	return []lingo.Expression{
	{{- range .Columns }}
		t.{{.MethodName}}(),
	{{- end }}
	}
}

func (t {{.StructName}}) ToSQL(d lingo.Dialect) (sql.Data, error) {
	return expr.Table(t).ToSQL(d)
}

func (t {{ .StructName }}) GetName() lingo.Expression {
	return expr.TableName(t)
}

func (t {{ .StructName }}) GetAlias() lingo.Expression {
	return t.alias
}

// Column Functions

{{ $receiverName := .StructName }}
{{- range .Columns -}}
func (t {{ $receiverName }}) {{ .MethodName }}() {{ .PathType.ShortPkg }}.{{ .PathType.Type }} {
	return expr.Column(t, expr.Lit("{{.DBName}}")).ToSQL
}

{{ end }}
`

var exportedTemplate = createWithImports("exported", exportedTemplateString)

const exportedTemplateString = `{{ .GeneratedComment }}

// +build !nolingo

package {{ .PackageName }}

{{ template "imports" .Imports }}

var instance = New()

func {{ .Prefix }}() {{ .StructName }} {
	return instance
}

{{ range .Columns }}
func {{ .MethodName }}() {{ .PathType.ShortPkg }}.{{ .PathType.Type }} {
	return instance.{{ .MethodName }}()
}
{{ end }}
`
