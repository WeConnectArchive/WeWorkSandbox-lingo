package generator

import (
	"fmt"

	. "github.com/dave/jennifer/jen"
)

const fmtSchemaHeaderComment = "Code generated by Lingo for schema %s - DO NOT EDIT"
const fmtTableHeaderComment = "Code generated by Lingo for table %s.%s - DO NOT EDIT"

const pkgCore = "github.com/weworksandbox/lingo/core"
const pkgCorePath = "github.com/weworksandbox/lingo/core/path"

const typeColumn = "Column"
const typeDialect = "Dialect"
const typeName = "Name"
const typeSQL = "SQL"

const addrOf = "&"
const ptr = "*"
const tableReceiver = "q"
const packageInstance = "instance"
const colon = ":"

const funcAs = "As"
const funcNew = "New"
const funcGetSQL = "GetSQL"
const funcGetColumns = "GetColumns"
const funcGetAlias = "GetAlias"
const funcGetName = "GetName"
const funcGetParent = "GetParent"
const funcExpandTable = "ExpandTableWithDialect"

const alias = "alias"
const aliasField = "_" + alias
const nameField = "_name"

type TableInfo interface {
	Name() string
	Schema() string
	Columns() []Column
	ForeignKeys() []ForeignKey
}

func GenerateTable(settings Settings, info TableInfo, dbToPath DBToPathType) (string, error) {
	tableName := info.Name()
	columns := convertCols(info.Columns(), settings.ReplaceFieldName, dbToPath)

	f := NewFile(ToPackageName(tableName))
	f.HeaderComment(fmt.Sprintf(fmtTableHeaderComment, info.Schema(), tableName))
	f.ImportName(pkgCore, "core")
	f.ImportName(pkgCorePath, "path")
	f.Add(createAsAlias(tableName))
	f.Line()
	f.Add(createNewFunc(tableName))
	f.Line()
	f.Add(createPrivateNewFunc(tableName, columns))
	f.Line()
	f.Add(createStruct(tableName, columns))
	f.Line()
	f.Comment("core.Table Functions")
	f.Line()
	f.Add(createGetColumnsFunc(tableName, columns))
	f.Line()
	f.Add(createGetSQLFunc(tableName))
	f.Line()
	f.Add(createGetAliasFunc(tableName))
	f.Line()
	f.Add(createGetNameFunc(tableName))
	f.Line()
	f.Add(createGetParentSchemaFunc(info.Schema(), tableName))
	f.Line()
	f.Comment("Column Functions")
	f.Line()
	for colFunc := range createColumnFunctions(tableName, columns) {
		f.Add(colFunc)
		f.Line()
	}

	return Render(f)
}

// createAlias makes the `As` function
//
// func As(alias string) QResourceGroup {
//    return newQResourceGroup(alias)
// }
func createAsAlias(table string) *Statement {
	structName := ToTableStruct(table)
	newStructFuncName := "new" + structName

	f := Func().Id(funcAs).Params(Id(alias).String()).Qual("", structName)
	f.Block(
		Return(Id(newStructFuncName).Call(Id(alias))),
	)
	return f
}

// createNewFunc makes the exported New function
//
// func New() QResourceGroup {
//    return newQResourceGroup("")
// }
func createNewFunc(table string) *Statement {
	structName := ToTableStruct(table)
	newStructFuncName := "new" + structName

	f := Func().Id(funcNew).Params().Qual("", structName)
	f.Block(
		Return(Id(newStructFuncName).Call(Lit(""))),
	)
	return f
}

// createPrivateNewFunc makes the private function that creates the 'Q' struct
//
// func newQResourceGroup(alias string) QResourceGroup {
//    q := QResourceGroup{
//       _alias: alias,
//    }
//    q.uuid = path.NewBinaryPath(q, "uuid")
//    q.name = path.NewStringPath(q, "name")
//    q.internalName = path.NewStringPath(q, "internal_name")
//    q.description = path.NewStringPath(q, "description")
//    q.version = path.NewIntPath(q, "version")
//    return q
// }
func createPrivateNewFunc(table string, cols []*column) *Statement {
	structName := ToTableStruct(table)
	newStructFuncName := "new" + structName

	f := Func().Id(newStructFuncName).Params(Id(alias).String()).Qual("", structName)
	f.BlockFunc(func(g *Group) {
		g.Id(tableReceiver).Op(":=").Qual("", structName).Values(Dict{
			Id(aliasField): Id(alias),
		})

		// q.uuid = path.NewBinaryPath(q, "uuid")
		for _, col := range cols {
			newColType := Qual(col.NewPathTypeName()).Call(Id(tableReceiver), Lit(col.DatabaseName()))
			g.Id(tableReceiver).Dot(col.MemberName()).Op("=").Add(newColType)
		}

		g.Return(Id(tableReceiver))
	})
	return f
}

// createStruct makes the 'Q' named struct
//
// type QResourceGroup struct {
//    _alias       string
//    uuid         path.BinaryPath
//    name         path.StringPath
//    internalName path.StringPath
//    description  path.StringPath
//    version      path.IntPath
//    createdAt    path.TimePath
//    updatedAt    path.TimePath
//    deletedAt    path.TimePath
// }
func createStruct(table string, cols []*column) *Statement {
	structName := ToTableStruct(table)

	return Type().Id(structName).StructFunc(func(g *Group) {
		g.Id(aliasField).String()

		// internalName path.StringPath
		for _, col := range cols {
			g.Id(col.MemberName()).Add(Qual(col.PathTypeName()))
		}
	})
}

// createGetColumnsFunc makes the GetColumns() function
//
// func (q qResourceGroup) GetColumns() []core.Column {
//    return []core.Column{
//       q.uuid,
//       q.name,
//       q.internalName,
//       q.description,
//       q.version,
//    }
// }
func createGetColumnsFunc(table string, cols []*column) *Statement {
	structName := ToTableStruct(table)

	f := Func().Parens(Id(tableReceiver).Qual("", structName)).Id(funcGetColumns).Call().Index().Qual(pkgCore, typeColumn)
	f.BlockFunc(func(g *Group) {
		g.ReturnFunc(func(r *Group) {
			r.Index().Qual(pkgCore, typeColumn).ValuesFunc(func(v *Group) {
				for _, col := range cols {
					v.Line().Id(tableReceiver).Dot(col.MemberName())
				}
				v.Line()
			})
		})
	})
	return f
}

// createGetSQLFunc makes the GetSQL(d core.Dialect) function
//
// func (q qResourceGroup) GetSQL(d core.Dialect, sql core.SQL) error {
//    return path.ExpandTableWithDialect(d, q, sql)
// }
func createGetSQLFunc(table string) *Statement {
	structName := ToTableStruct(table)
	dialect := "d"
	sqlName := "sql"

	f := Func().Parens(Id(tableReceiver).Qual("", structName)).Id(funcGetSQL).Call(Id(dialect).Qual(pkgCore, typeDialect), Id(sqlName).Qual(pkgCore, typeSQL)).Error()
	f.Block(Return(Qual(pkgCorePath, funcExpandTable).Call(Id(dialect), Id(tableReceiver), Id(sqlName))))
	return f
}

// createGetAliasFunc makes the GetSQL(d core.Dialect) function
//
// func (q qResourceGroup) GetAlias() string {
//    return q._alias
// }
func createGetAliasFunc(table string) *Statement {
	structName := ToTableStruct(table)

	f := Func().Parens(Id(tableReceiver).Qual("", structName)).Id(funcGetAlias).Call().String()
	f.Block(Return(Id(tableReceiver).Dot(aliasField)))
	return f
}

// createGetNameFunc makes the GetSQL(d core.Dialect) function
//
// func (q qResourceGroup) GetName() string {
//    return "resource_group"
// }
func createGetNameFunc(table string) *Statement {
	structName := ToTableStruct(table)

	f := Func().Parens(Id(tableReceiver).Qual("", structName)).Id(funcGetName).Call().String()
	f.Block(Return(Lit(table)))
	return f
}

// createGetParentSchemaFunc makes the GetParent() string function
//
// func (q qResourceGroup) GetParent() string {
//    return "resource_group"
// }
func createGetParentSchemaFunc(schema, table string) *Statement {
	structName := ToTableStruct(table)

	f := Func().Parens(Id(tableReceiver).Qual("", structName)).Id(funcGetParent).Call().String()
	f.Block(Return(Lit(schema)))
	return f
}

// createColumnFunctions makes each columns Path function
//
// func (q QResourceGroup) UUID() path.BinaryPath {
//    return q.uuid
// }
//
// func (q QResourceGroup) Name() path.StringPath {
//    return q.name
// }
func createColumnFunctions(table string, cols []*column) <-chan *Statement {
	structName := ToTableStruct(table)

	var response = make(chan *Statement)
	go func() {
		defer close(response)
		for _, col := range cols {
			f := Func().Parens(Id(tableReceiver).Qual("", structName)).Id(col.MethodName()).Call().Add(Qual(col.PathTypeName()))
			f.Block(Return(Id(tableReceiver).Dot(col.MemberName())))
			response <- f
		}
	}()
	return response
}
