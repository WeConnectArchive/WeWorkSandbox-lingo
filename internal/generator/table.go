package generator

import (
	"fmt"

	"github.com/dave/jennifer/jen"
)

const fmtSchemaHeaderComment = "Code generated by Lingo for schema %s - DO NOT EDIT"
const fmtTableHeaderComment = "Code generated by Lingo for table %s.%s - DO NOT EDIT"

const pkgCore = "github.com/weworksandbox/lingo/pkg/core"
const pkgCorePath = "github.com/weworksandbox/lingo/pkg/core/path"

const typeColumn = "Column"
const typeDialect = "Dialect"
const typeName = "Name"
const typeSQL = "SQL"
const typeSchema = "schema"

const addrOf = "&"
const ptr = "*"
const tableReceiver = "q"
const packageInstance = "instance"
const colon = ":"

const funcAs = "As"
const funcNew = "New"
const funcGetSQL = "GetSQL"
const funcGetColumns = "GetColumns"
const funcGetAlias = "GetAlias"
const funcGetName = "GetName"
const funcGetParent = "GetParent"
const funcExpandTable = "ExpandTableWithDialect"

const alias = "alias"
const aliasField = "_" + alias
const nameField = "_name"

type TableInfo interface {
	Name() string
	Schema() string
	Columns() []Column
	ForeignKeys() []ForeignKey
}

func GenerateTable(info TableInfo, columns []*column) (string, error) {
	tableName := info.Name()

	f := jen.NewFile(ToPackageName(tableName))
	f.HeaderComment(fmt.Sprintf(fmtTableHeaderComment, info.Schema(), tableName))
	f.ImportName(pkgCore, "core")
	f.ImportName(pkgCorePath, "path")
	f.Add(createAsAlias(tableName))
	f.Line()
	f.Add(createNewFunc(tableName))
	f.Line()
	f.Add(createPrivateNewFunc(tableName, columns))
	f.Line()
	f.Add(createStruct(tableName, columns))
	f.Line()
	f.Comment("core.Table Functions")
	f.Line()
	f.Add(createGetColumnsFunc(tableName, columns))
	f.Line()
	f.Add(createGetSQLFunc(tableName))
	f.Line()
	f.Add(createGetAliasFunc(tableName))
	f.Line()
	f.Add(createGetNameFunc(tableName))
	f.Line()
	f.Add(createGetParentSchemaFunc(info.Schema(), tableName))
	f.Line()
	f.Comment("Column Functions")
	f.Line()
	for colFunc := range createColumnFunctions(tableName, columns) {
		f.Add(colFunc)
		f.Line()
	}

	return Render(f)
}

// createAlias makes the `As` function
//
// func As(alias string) QResourceGroup {
//    return newQResourceGroup(alias)
// }
func createAsAlias(table string) *jen.Statement {
	structName := ToTableStruct(table)
	newStructFuncName := "new" + structName

	f := jen.Func().Id(funcAs).Params(jen.Id(alias).String()).Qual("", structName)
	f.Block(
		jen.Return(jen.Id(newStructFuncName).Call(jen.Id(alias))),
	)
	return f
}

// createNewFunc makes the exported New function
//
// func New() QResourceGroup {
//    return newQResourceGroup("")
// }
func createNewFunc(table string) *jen.Statement {
	structName := ToTableStruct(table)
	newStructFuncName := "new" + structName

	f := jen.Func().Id(funcNew).Params().Qual("", structName)
	f.Block(
		jen.Return(jen.Id(newStructFuncName).Call(jen.Lit(""))),
	)
	return f
}

// createPrivateNewFunc makes the private function that creates the 'Q' struct
//
// func newQResourceGroup(alias string) QResourceGroup {
//    q := QResourceGroup{
//       _alias: alias,
//    }
//    q.uuid = path.NewBinaryPath(q, "uuid")
//    q.name = path.NewStringPath(q, "name")
//    q.internalName = path.NewStringPath(q, "internal_name")
//    q.description = path.NewStringPath(q, "description")
//    q.version = path.NewIntPath(q, "version")
//    return q
// }
func createPrivateNewFunc(table string, cols []*column) *jen.Statement {
	structName := ToTableStruct(table)
	newStructFuncName := "new" + structName

	f := jen.Func().Id(newStructFuncName).Params(jen.Id(alias).String()).Qual("", structName)
	f.BlockFunc(func(g *jen.Group) {
		g.Id(tableReceiver).Op(":=").Qual("", structName).Values(jen.Dict{
			jen.Id(aliasField): jen.Id(alias),
		})

		// q.uuid = path.NewBinaryPath(q, "uuid")
		for _, col := range cols {
			newColType := jen.Qual(col.NewPathTypeName()).Call(jen.Id(tableReceiver), jen.Lit(col.DatabaseName()))
			g.Id(tableReceiver).Dot(col.MemberName()).Op("=").Add(newColType)
		}

		g.Return(jen.Id(tableReceiver))
	})
	return f
}

// createStruct makes the 'Q' named struct
//
// type QResourceGroup struct {
//    _alias       string
//    uuid         path.Binary
//    name         path.String
//    internalName path.String
//    description  path.String
//    version      path.Int
//    createdAt    path.Time
//    updatedAt    path.Time
//    deletedAt    path.Time
// }
func createStruct(table string, cols []*column) *jen.Statement {
	structName := ToTableStruct(table)

	return jen.Type().Id(structName).StructFunc(func(g *jen.Group) {
		g.Id(aliasField).String()

		// internalName path.String
		for _, col := range cols {
			g.Id(col.MemberName()).Add(jen.Qual(col.PathTypeName()))
		}
	})
}

// createGetColumnsFunc makes the GetColumns() function
//
// func (q qResourceGroup) GetColumns() []core.Column {
//    return []core.Column{
//       q.uuid,
//       q.name,
//       q.internalName,
//       q.description,
//       q.version,
//    }
// }
func createGetColumnsFunc(table string, cols []*column) *jen.Statement {
	structName := ToTableStruct(table)
	receiver := jen.Id(tableReceiver).Qual("", structName)

	f := jen.Func().Parens(receiver).Id(funcGetColumns).Call().Index().Qual(pkgCore, typeColumn)
	f.BlockFunc(func(g *jen.Group) {
		g.ReturnFunc(func(r *jen.Group) {
			r.Index().Qual(pkgCore, typeColumn).ValuesFunc(func(v *jen.Group) {
				for _, col := range cols {
					v.Line().Id(tableReceiver).Dot(col.MemberName())
				}
				v.Line()
			})
		})
	})
	return f
}

// createGetSQLFunc makes the GetSQL(d core.Dialect) function
//
// func (q qResourceGroup) GetSQL(d core.Dialect) (core.SQL, error) {
//    return path.ExpandTableWithDialect(d, q)
// }
func createGetSQLFunc(table string) *jen.Statement {
	structName := ToTableStruct(table)
	dialect := "d"

	receiver := jen.Id(tableReceiver).Qual("", structName)
	funcParam := jen.Id(dialect).Qual(pkgCore, typeDialect)
	returnVals := []jen.Code{jen.Qual(pkgCore, typeSQL), jen.Error()}

	f := jen.Func().Parens(receiver).Id(funcGetSQL).Call(funcParam).Params(returnVals...)
	f.Block(jen.Return(jen.Qual(pkgCorePath, funcExpandTable).Call(jen.Id(dialect), jen.Id(tableReceiver))))
	return f
}

// createGetAliasFunc makes the GetSQL(d core.Dialect) function
//
// func (q qResourceGroup) GetAlias() string {
//    return q._alias
// }
func createGetAliasFunc(table string) *jen.Statement {
	structName := ToTableStruct(table)

	f := jen.Func().Parens(jen.Id(tableReceiver).Qual("", structName)).Id(funcGetAlias).Call().String()
	f.Block(jen.Return(jen.Id(tableReceiver).Dot(aliasField)))
	return f
}

// createGetNameFunc makes the GetSQL(d core.Dialect) function
//
// func (q qResourceGroup) GetName() string {
//    return "resource_group"
// }
func createGetNameFunc(table string) *jen.Statement {
	structName := ToTableStruct(table)

	f := jen.Func().Parens(jen.Id(tableReceiver).Qual("", structName)).Id(funcGetName).Call().String()
	f.Block(jen.Return(jen.Lit(table)))
	return f
}

// createGetParentSchemaFunc makes the GetParent() string function
//
// func (q qResourceGroup) GetParent() string {
//    return "resource_group"
// }
func createGetParentSchemaFunc(schema, table string) *jen.Statement {
	structName := ToTableStruct(table)

	f := jen.Func().Parens(jen.Id(tableReceiver).Qual("", structName)).Id(funcGetParent).Call().String()
	f.Block(jen.Return(jen.Lit(schema)))
	return f
}

// createColumnFunctions makes each columns Path function
//
// func (q QResourceGroup) UUID() path.Binary {
//    return q.uuid
// }
//
// func (q QResourceGroup) Name() path.String {
//    return q.name
// }
func createColumnFunctions(table string, cols []*column) <-chan *jen.Statement {
	structName := ToTableStruct(table)

	var response = make(chan *jen.Statement)
	go func() {
		defer close(response)
		for _, col := range cols {
			receiver := jen.Id(tableReceiver).Qual("", structName)

			f := jen.Func().Parens(receiver).Id(col.MethodName()).Call().Add(jen.Qual(col.PathTypeName()))
			f.Block(jen.Return(jen.Id(tableReceiver).Dot(col.MemberName())))
			response <- f
		}
	}()
	return response
}
