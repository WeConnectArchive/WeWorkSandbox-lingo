package generator

import (
	"fmt"
	"io"
	"strings"
)

const fmtSchemaHeaderComment = "// Code generated by Lingo for schema %s - DO NOT EDIT\n\n"
const fmtTableHeaderComment = "// Code generated by Lingo for table %s.%s - DO NOT EDIT\n\n"

const PkgLingo = "github.com/weworksandbox/lingo"
const PkgExp = PkgLingo + "/expr"
const PkgOperator = PkgExp + "/operator"
const PkgSet = PkgExp + "/set"
const PkgPath = PkgExp + "/path"
const PkgSQL = PkgLingo + "/sql"

const typeColumn = "Column"
const typeDialect = "Dialect"
const typeName = "Name"
const typeData = "Data"
const typeTable = "Table"
const typeSchema = "schema"

const addrOf = "&"
const ptr = "*"
const tableReceiver = "q"
const pathReceiver = "p"
const packageInstance = "instance"
const buildTag = "+build"
const tagNoLingo = "!nolingo"

const funcAs = "As"
const funcNew = "New"
const funcToSQL = "ToSQL"
const funcGetColumns = "GetColumns"
const funcGetAlias = "GetAlias"
const funcGetName = "GetName"
const funcGetParent = "GetParent"
const funcExpandColumn = "ExpandColumnWithDialect"
const funcExpandTable = "ExpandTableWithDialect"

const entity = "entity"
const alias = "alias"
const aliasField = "_" + alias
const name = "name"
const nameField = "_" + name
const value = "value"

type TableInfo struct {
	Name        string
	Schema      string
	Columns     []column
	ForeignKeys []ForeignKey
}

type TableGenerator struct {
	GeneratedComment string
	SchemaName       string
	DBName           string
	PackageName      string
	StructName       string
	Columns          []column
	Imports          []string
}

func NewTable(info TableInfo) (TableGenerator, error) {
	t := TableGenerator{
		GeneratedComment: fmt.Sprintf(fmtTableHeaderComment, info.Schema, info.Name),
		SchemaName:       info.Schema,
		DBName:           info.Name,
		PackageName:      ToPackageName(info.Name),
		StructName:       ToTableStruct(info.Name),
		Columns:          info.Columns,
	}
	return t, nil
}

func (t TableGenerator) GenerateTable() (io.Reader, error) {
	defaultImports := []string{
		PkgLingo,
		PkgSQL,
	}
	t.Imports = determineImports(defaultImports, t.Columns)
	return generateFromTemplate(tableTemplate, t)
}

func (t TableGenerator) GenerateExported() (io.Reader, error) {
	t.Imports = determineImports([]string{}, t.Columns)
	return generateFromTemplate(exportedTemplate, t)
}

func determineImports(defaultImports []string, cols []column) []string {
	var thirdParty []string

	for _, col := range cols {
		pkg := col.PathType.Pkg()

		if containsString(defaultImports, pkg) || containsString(thirdParty, pkg) {
			continue
		}
		if strings.HasPrefix(pkg, PkgLingo) {
			defaultImports = append(defaultImports, pkg)
		} else {
			thirdParty = append(thirdParty, pkg)
		}
	}

	if len(thirdParty) > 0 {
		thirdParty = append(thirdParty, "")
	}
	return append(thirdParty, defaultImports...)
}

func containsString(strs []string, value string) bool {
	for _, str := range strs {
		if strings.EqualFold(str, value) {
			return true
		}
	}
	return false
}

//
//func GenerateTable(info TableInfo, columns []*column) (string, error) {
//	tableName := info.Name()
//
//	f := jen.NewFile(ToPackageName(tableName))
//	f.HeaderComment(fmt.Sprintf(fmtTableHeaderComment, info.Schema(), tableName))
//	f.HeaderComment(createBuildTag(tagNoLingo))
//	f.ImportName(PkgLingo, "lingo")
//	f.ImportName(PkgPath, "path")
//	f.ImportName(PkgSQL, "sql")
//	f.Add(createAsAlias(tableName))
//	f.Line()
//	f.Add(createNewFunc(tableName))
//	f.Line()
//	f.Add(createPrivateNewFunc(tableName, columns))
//	f.Line()
//	f.Add(createStruct(tableName, columns))
//	f.Line()
//	f.Comment("lingo.Table Functions")
//	f.Line()
//	f.Add(createGetColumnsFunc(tableName, columns))
//	f.Line()
//	f.Add(createToSQLFunc(tableName))
//	f.Line()
//	f.Add(createGetAliasFunc(tableName))
//	f.Line()
//	f.Add(createGetNameFunc(tableName))
//	f.Line()
//	f.Add(createGetParentSchemaFunc(info.Schema(), tableName))
//	f.Line()
//	f.Comment("Column Functions")
//	f.Line()
//	for colFunc := range createColumnFunctions(tableName, columns) {
//		f.Add(colFunc)
//		f.Line()
//	}
//
//	return Render(f)
//}
//
//// createAlias makes the `As` function
////
//// func As(alias string) QResourceGroup {
////    return newQResourceGroup(alias)
//// }
//func createAsAlias(table string) *jen.Statement {
//	structName := ToTableStruct(table)
//	newStructFuncName := "new" + structName
//
//	f := jen.Func().Id(funcAs).Params(jen.Id(alias).String()).Qual("", structName)
//	f.Block(
//		jen.Return(jen.Id(newStructFuncName).Call(jen.Id(alias))),
//	)
//	return f
//}
//
//// createNewFunc makes the exported New function
////
//// func New() QResourceGroup {
////    return newQResourceGroup("")
//// }
//func createNewFunc(table string) *jen.Statement {
//	structName := ToTableStruct(table)
//	newStructFuncName := "new" + structName
//
//	f := jen.Func().Id(funcNew).Params().Qual("", structName)
//	f.Block(
//		jen.Return(jen.Id(newStructFuncName).Call(jen.Lit(""))),
//	)
//	return f
//}
//
//// createPrivateNewFunc makes the private function that creates the 'Q' struct
////
//// func newQResourceGroup(alias string) QResourceGroup {
////    q := QResourceGroup{
////       _alias: alias,
////    }
////    q.uuid = path.NewBinaryPath(q, "uuid")
////    q.name = path.NewStringPath(q, "name")
////    q.internalName = path.NewStringPath(q, "internal_name")
////    q.description = path.NewStringPath(q, "description")
////    q.version = path.NewIntPath(q, "version")
////    return q
//// }
//func createPrivateNewFunc(table string, cols []*column) *jen.Statement {
//	structName := ToTableStruct(table)
//	newStructFuncName := "new" + structName
//
//	f := jen.Func().Id(newStructFuncName).Params(jen.Id(alias).String()).Qual("", structName)
//	f.BlockFunc(func(g *jen.Group) {
//		//    q := QResourceGroup{
//		//       _alias: alias,
//		//    }
//		g.Id(tableReceiver).Op(":=").Qual("", structName).Values(jen.Dict{
//			jen.Id(aliasField): jen.Id(alias),
//		})
//
//		// q.uuid = path.NewBinaryPath(q, "uuid")
//		for _, col := range cols {
//			newColType := jen.Qual(col.NewPathTypeName()).Call(jen.Id(tableReceiver), jen.Lit(col.DatabaseName()))
//			g.Id(tableReceiver).Dot(col.MemberName()).Op("=").Add(newColType)
//		}
//
//		g.Return(jen.Id(tableReceiver))
//	})
//	return f
//}
//
//// createStruct makes the 'Q' named struct
////
//// type QResourceGroup struct {
////    _alias       string
////    uuid         path.Binary
////    name         path.String
////    internalName path.String
////    description  path.String
////    version      path.Int
////    createdAt    path.Time
////    updatedAt    path.Time
////    deletedAt    path.Time
//// }
//func createStruct(table string, cols []*column) *jen.Statement {
//	structName := ToTableStruct(table)
//
//	return jen.Type().Id(structName).StructFunc(func(g *jen.Group) {
//		g.Id(aliasField).String()
//
//		// internalName path.String
//		for _, col := range cols {
//			g.Id(col.MemberName()).Add(jen.Qual(col.PathTypeName()))
//		}
//	})
//}
//
//// createGetColumnsFunc makes the GetColumns() function
////
//// func (q qResourceGroup) GetColumns() []lingo.Column {
////    return []lingo.Column{
////       q.uuid,
////       q.name,
////       q.internalName,
////       q.description,
////       q.version,
////    }
//// }
//func createGetColumnsFunc(table string, cols []*column) *jen.Statement {
//	structName := ToTableStruct(table)
//	receiver := jen.Id(tableReceiver).Qual("", structName)
//
//	f := jen.Func().Parens(receiver).Id(funcGetColumns).Call().Index().Qual(PkgLingo, typeColumn)
//	f.BlockFunc(func(g *jen.Group) {
//		g.ReturnFunc(func(r *jen.Group) {
//			r.Index().Qual(PkgLingo, typeColumn).ValuesFunc(func(v *jen.Group) {
//				for _, col := range cols {
//					v.Line().Id(tableReceiver).Dot(col.MemberName())
//				}
//				v.Line()
//			})
//		})
//	})
//	return f
//}
//
//// createToSQLFunc makes the ToSQL(d lingo.Dialect) function
////
//// func (q qResourceGroup) ToSQL(d lingo.Dialect) (sql.Data, error) {
////    return path.ExpandTableWithDialect(d, q)
//// }
//func createToSQLFunc(table string) *jen.Statement {
//	structName := ToTableStruct(table)
//	dialect := "d"
//
//	receiver := jen.Id(tableReceiver).Qual("", structName)
//	funcParam := jen.Id(dialect).Qual(PkgLingo, typeDialect)
//	returnVals := []jen.Code{jen.Qual(PkgSQL, typeData), jen.Error()}
//
//	f := jen.Func().Parens(receiver).Id(funcToSQL).Call(funcParam).Params(returnVals...)
//	f.Block(jen.Return(jen.Qual(PkgPath, funcExpandTable).Call(jen.Id(dialect), jen.Id(tableReceiver))))
//	return f
//}
//
//// createGetAliasFunc makes the ToSQL(d lingo.Dialect) function
////
//// func (q qResourceGroup) GetAlias() string {
////    return q._alias
//// }
//func createGetAliasFunc(table string) *jen.Statement {
//	structName := ToTableStruct(table)
//
//	f := jen.Func().Parens(jen.Id(tableReceiver).Qual("", structName)).Id(funcGetAlias).Call().String()
//	f.Block(jen.Return(jen.Id(tableReceiver).Dot(aliasField)))
//	return f
//}
//
//// createGetNameFunc makes the ToSQL(d lingo.Dialect) function
////
//// func (q qResourceGroup) GetName() string {
////    return "resource_group"
//// }
//func createGetNameFunc(table string) *jen.Statement {
//	structName := ToTableStruct(table)
//
//	f := jen.Func().Parens(jen.Id(tableReceiver).Qual("", structName)).Id(funcGetName).Call().String()
//	f.Block(jen.Return(jen.Lit(table)))
//	return f
//}
//
//// createGetParentSchemaFunc makes the GetParent() string function
////
//// func (q qResourceGroup) GetParent() string {
////    return "resource_group"
//// }
//func createGetParentSchemaFunc(schema, table string) *jen.Statement {
//	structName := ToTableStruct(table)
//
//	f := jen.Func().Parens(jen.Id(tableReceiver).Qual("", structName)).Id(funcGetParent).Call().String()
//	f.Block(jen.Return(jen.Lit(schema)))
//	return f
//}
//
//// createColumnFunctions makes each columns Path function
////
//// func (q QResourceGroup) UUID() path.Binary {
////    return q.uuid
//// }
////
//// func (q QResourceGroup) Name() path.String {
////    return q.name
//// }
//func createColumnFunctions(table string, cols []*column) <-chan *jen.Statement {
//	structName := ToTableStruct(table)
//
//	var response = make(chan *jen.Statement)
//	go func() {
//		defer close(response)
//		for _, col := range cols {
//			receiver := jen.Id(tableReceiver).Qual("", structName)
//
//			f := jen.Func().Parens(receiver).Id(col.MethodName()).Call().Add(jen.Qual(col.PathTypeName()))
//			f.Block(jen.Return(jen.Id(tableReceiver).Dot(col.MemberName())))
//			response <- f
//		}
//	}()
//	return response
//}
