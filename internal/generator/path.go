package generator

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"strings"
	"text/template"
)

const (
	GenPathFileHeader = "// Code generated by an internal Lingo tool, genpaths.go - DO NOT EDIT"
)

var pathExpander *template.Template

func init() {
	var err error
	pathExpander, err = template.New("path").Parse(pathTemplateString)
	if err != nil {
		panic(fmt.Errorf("unable to create path template: %w", err).Error())
	}
}

type Ops struct {
	Set, Equality, Comparison, Nullable, In, Between bool
}

type Path struct {
	Name       string
	Filename   string
	GoType     string
	Imports    []string
	Operations Ops
}

func (p Path) Generate() (io.Reader, error) {
	var b strings.Builder
	err := pathExpander.Execute(&b, p)
	if err != nil {
		return nil, fmt.Errorf("unable to generate path '%s' data: %w", p.Name, err)
	}

	formatted, err := format.Source([]byte(b.String()))
	if err != nil {
		s := bufio.NewScanner(strings.NewReader(b.String()))
		var line int
		for s.Scan() {
			line++
			log.Printf("%d %s", line, s.Text())
		}

		return nil, fmt.Errorf("unable to format code for path '%s': %w", p.Name, err)
	}
	return bytes.NewReader(formatted), nil
}

const pathTemplateString = GenPathFileHeader + `

package path
{{ $length := len .Imports }}{{ if gt $length 0 }}
import ({{ range $import := .Imports }}{{ if $importLen := len $import }}
	"{{ $import }}"{{ else }}
{{ end }}{{ end -}}
){{ end }}

func New{{ .Name }}WithAlias(e lingo.Table, name, alias string) {{ .Name }} {
	return {{ .Name }}{
		entity: e,
		name:   name,
		alias:  alias,
	}
}

func New{{ .Name }}(e lingo.Table, name string) {{ .Name }} {
	return New{{ .Name }}WithAlias(e, name, "")
}

type {{ .Name }} struct {
	entity lingo.Table
	name   string
	alias  string
}

func (p {{ .Name }}) GetParent() lingo.Table {
	return p.entity
}

func (p {{ .Name }}) GetName() string {
	return p.name
}

func (p {{ .Name }}) GetAlias() string {
	return p.alias
}

func (p {{ .Name }}) As(alias string) {{ .Name }} {
	p.alias = alias
	return p
}

func (p {{ .Name }}) ToSQL(d lingo.Dialect) (sql.Data, error) {
	return ExpandColumnWithDialect(d, p)
}

{{- if .Operations.Set }}

func (p {{ .Name }}) To(value {{ .GoType }}) set.Set {
	return set.NewSet(p, expr.NewValue(value))
}

func (p {{ .Name }}) ToExpr(exp lingo.Expression) set.Set {
	return set.NewSet(p, exp)
}
{{- end -}}

{{ if .Operations.Equality }}

func (p {{ .Name }}) Eq(value {{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.Eq, expr.NewValue(value))
}

func (p {{ .Name }}) EqPath(exp lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.Eq, exp)
}

func (p {{ .Name }}) NotEq(value {{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.NotEq, expr.NewValue(value))
}

func (p {{ .Name }}) NotEqPath(exp lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.NotEq, exp)
}
{{- end -}}

{{ if .Operations.Comparison }}

func (p {{ .Name }}) LT(value {{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.LessThan, expr.NewValue(value))
}

func (p {{ .Name }}) LTPath(exp lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.LessThan, exp)
}

func (p {{ .Name }}) LTOrEq(value {{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.LessThanOrEqual, expr.NewValue(value))
}

func (p {{ .Name }}) LTOrEqPath(exp lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.LessThanOrEqual, exp)
}

func (p {{ .Name }}) GT(value {{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.GreaterThan, expr.NewValue(value))
}

func (p {{ .Name }}) GTPath(exp lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.GreaterThan, exp)
}

func (p {{ .Name }}) GTOrEq(value {{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.GreaterThanOrEqual, expr.NewValue(value))
}

func (p {{ .Name }}) GTOrEqPath(exp lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.GreaterThanOrEqual, exp)
}
{{- end -}}

{{ if .Operations.Nullable }}

func (p {{ .Name }}) IsNull() operator.Unary {
	return operator.NewUnary(p, operator.Null)
}

func (p {{ .Name }}) IsNotNull() operator.Unary {
	return operator.NewUnary(p, operator.NotNull)
}
{{- end -}}

{{ if .Operations.In }}

func (p {{ .Name }}) In(values ...{{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.In, expr.NewParens(expr.NewValue(values)))
}

func (p {{ .Name }}) InPaths(exps ...lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.In, expr.NewParens(expr.ToList(exps)))
}

func (p {{ .Name }}) NotIn(values ...{{ .GoType }}) operator.Binary {
	return operator.NewBinary(p, operator.NotIn, expr.NewParens(expr.NewValue(values)))
}

func (p {{ .Name }}) NotInPaths(exps ...lingo.Expression) operator.Binary {
	return operator.NewBinary(p, operator.NotIn, expr.NewParens(expr.ToList(exps)))
}
{{- end -}}

{{ if .Operations.Between }}

func (p {{ .Name }}) Between(first, second {{ .GoType }}) operator.Binary {
	and := expr.NewParens(expr.NewValue(first).And(expr.NewValue(second)))
	return operator.NewBinary(p, operator.Between, and)
}

func (p {{ .Name }}) BetweenPaths(firstExp, secondExp lingo.Expression) operator.Binary {
	and := expr.NewParens(operator.NewBinary(firstExp, operator.And, secondExp))
	return operator.NewBinary(p, operator.Between, and)
}

func (p {{ .Name }}) NotBetween(first, second {{ .GoType }}) operator.Binary {
	and := expr.NewParens(expr.NewValue(first).And(expr.NewValue(second)))
	return operator.NewBinary(p, operator.NotBetween, and)
}

func (p {{ .Name }}) NotBetweenPaths(firstExp, secondExp lingo.Expression) operator.Binary {
	and := expr.NewParens(operator.NewBinary(firstExp, operator.And, secondExp))
	return operator.NewBinary(p, operator.NotBetween, and)
}

{{- end -}}
`
