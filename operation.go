// Code generated by go2go; DO NOT EDIT.


//line operation.go2:1
package lingo

//line operation.go2:1
import (
//line operation.go2:1
 "fmt"
//line operation.go2:1
 "reflect"
//line operation.go2:1
 "regexp"
//line operation.go2:1
 "strconv"
//line operation.go2:1
 "strings"
//line operation.go2:1
 "sync/atomic"
//line operation.go2:1
 "testing"
//line operation.go2:1
)

//line operation.go2:10
type Operation interface {
	Expression
	Operator() Operator
	Arg(idx int) Expression
	Args() []Expression
}

//line operation.go2:48
func NewPredicateOperation(op Operator, args ...Expression) PredicateOperation {
	return PredicateOperation(instantiate୦୦NewSimpleOperation୦bool(op, args...))
}

//line operation.go2:51
type PredicateOperation instantiate୦୦SimpleOperation୦bool

//line operation.go2:52
func (o PredicateOperation) Type() reflect.Type { return o.Type() }
func (o PredicateOperation) String() string                             { return VisitWithDefaultToStringBuilder(o) }
func (o PredicateOperation) Not() PredicateExpression                   { return NewPredicateOperation(OpNot, o) }
func (o PredicateOperation) Operator() Operator                         { return o.op }
func (o PredicateOperation) Args() []Expression                         { return o.args }
func (o PredicateOperation) Arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

//line operation.go2:66
func NewOpAnd(l, r Expression) BooleanExpression { return NewBooleanOperation(OpAnd, l, r) }
func NewOpNot(e Expression) BooleanExpression                            { return NewBooleanOperation(OpNot, e) }
func NewOpOr(l, r Expression) BooleanExpression                          { return NewBooleanOperation(OpOr, l, r) }
func NewIsNull(e Expression) BooleanExpression                           { return NewBooleanOperation(OpIsNull, e) }
func NewIsNotNull(e Expression) BooleanExpression                        { return NewBooleanOperation(OpIsNotNull, e) }
func NewOpEqual(l, r Expression) BooleanExpression                       { return NewBooleanOperation(OpEqual, l, r) }
func NewOpGreaterThan(l, r Expression) BooleanExpression {
//line operation.go2:72
 return NewBooleanOperation(OpGreaterThan, l, r)
//line operation.go2:72
}
func NewOpLessThan(l, r Expression) BooleanExpression { return NewBooleanOperation(OpLessThan, l, r) }
func NewOpGreaterThanOrEqual(l, r Expression) BooleanExpression {
//line operation.go2:74
 return NewBooleanOperation(OpGreaterThanOrEqual, l, r)
//line operation.go2:74
}
func NewOpLessThanOrEqual(l, r Expression) BooleanExpression {
//line operation.go2:75
 return NewBooleanOperation(OpLessThanOrEqual, l, r)
//line operation.go2:75
}
func NewOpBetween(p, l, r Expression) BooleanExpression {
//line operation.go2:76
 return NewBooleanOperation(OpBetween, p, l, r)
//line operation.go2:76
}
func NewOpNotBetween(p, l, r Expression) BooleanExpression {
//line operation.go2:77
 return NewBooleanOperation(OpNotBetween, p, l, r)
//line operation.go2:77
}

//line operation.go2:80
func NewBooleanOperation(op Operator, args ...Expression) BooleanOperation {
	return BooleanOperation{
		PredicateOperation: NewPredicateOperation(op, args...),
	}
}

//line operation.go2:85
type BooleanOperation struct {
	PredicateOperation
}

//line operation.go2:88
func (o BooleanOperation) Type() reflect.Type { return o.PredicateOperation.Type() }
func (o BooleanOperation) String() string                             { return VisitWithDefaultToStringBuilder(o) }

func (o BooleanOperation) As(alias string) BooleanExpression {
	return o.AsPath(instantiate୦୦NewSimplePathForVariable୦bool(false, alias))
}
func (o BooleanOperation) AsPath(p instantiate୦୦TypedPath୦bool,) BooleanExpression {
	return NewBooleanOperation(OpAlias, o, p)
}

func (o BooleanOperation) And(e PredicateExpression) BooleanExpression {
	return NewOpAnd(o, e)
}
func (o BooleanOperation) Not() BooleanExpression {
	return NewOpNot(o)
}
func (o BooleanOperation) Or(e PredicateExpression) BooleanExpression {
	return NewOpOr(o, e)
}

func (o BooleanOperation) IsTrue() BooleanExpression {
	return o.EqValue(true)
}
func (o BooleanOperation) IsFalse() BooleanExpression {
	return o.EqValue(false)
}

func (o BooleanOperation) EqValue(v bool) BooleanExpression {
	return o.Eq(instantiate୦୦NewSimpleConstant୦bool(v))
}
func (o BooleanOperation) Eq(e instantiate୦୦TypedExpression୦bool,) BooleanExpression {
	return NewOpEqual(o, e)
}

//line operation.go2:272
func NewStringOperation(op Operator, args ...Expression) StringOperation {
	return StringOperation{
		mixin: instantiate୦୦NewSimpleOperation୦string(op, args...),
	}
}

//line operation.go2:277
type StringOperation struct {
	StringExpression
	mixin instantiate୦୦SimpleOperation୦string
}

//line operation.go2:281
func (o StringOperation) Type() reflect.Type { return o.mixin.Type() }
func (o StringOperation) String() string                              { return VisitWithDefaultToStringBuilder(o) }

func (o StringOperation) As(alias instantiate୦୦TypedPath୦string,) StringExpression {
	return NewStringOperation(OpAlias, o, alias)
}
func (o StringOperation) Alias(alias string) StringExpression {
	return o.As(instantiate୦୦NewSimplePathForVariable୦string("", alias))
}

//line operation.go2:293
type Operator interface {
	Type() reflect.Type
}

type Category int

const (
//line operation.go2:301
 CatUnknown Category = iota

//line operation.go2:304
 CatArithmetic

//line operation.go2:307
 CatAssignment

//line operation.go2:310
 CatBitwise

//line operation.go2:314
 CatComparison

//line operation.go2:318
 CatLogical

//line operation.go2:321
 CatSet

//line operation.go2:324
 CatString

//line operation.go2:327
 CatNumeric

//line operation.go2:330
 CatUnary

//line operation.go2:334
 CatOthers

//line operation.go2:337
 CatLastCategory
)

//line operation.go2:341
func (c Category) Operators() []Operator {
	ops := make([]Operator, len(categoryToOperators[c]))
	copy(ops, categoryToOperators[c])
	return ops
}

//line operation.go2:348
type Op int

func (op Op) Type() reflect.Type {
	return reflect.TypeOf(op)
}

const (
//line operation.go2:356
 OpUnknown Op = iota

//line operation.go2:360
 OpAddition
				OpSubtraction
				OpMultiplication
				OpDivision
				OpModulo

//line operation.go2:368
 OpAssign
				OpAlias

//line operation.go2:373
 OpBitwiseAND
				OpBitwiseNOT
				OpBitwiseOR
				OpBitwiseXOR

//line operation.go2:380
 OpIsNull
				OpIsNotNull
				OpEqual
				OpNotEqual
				OpLessThan
				OpLessThanOrEqual
				OpGreaterThan
				OpGreaterThanOrEqual

//line operation.go2:391
 OpAnd
				OpOr
				OpNot
				OpIn
				OpNotIn
				OpBetween
				OpNotBetween
				OpAny
				OpAll
				OpSome
				OpExists

//line operation.go2:405
 OpSet
				OpList
				OpUnion
				OpExcept
				OpIntersect

//line operation.go2:413
 OpStringCast
				OpStringConcat

//line operation.go2:418
 OpAbs
				OpCeiling
				OpFloor
				OpMax
				OpMin
				OpNumCast
				OpRound
				OpSquareRoot

//line operation.go2:429
 OpSingleton
				OpNegate
				OpCurrentTimestamp

//line operation.go2:434
 OpCount
				OpLike
				OpNotLike

//line operation.go2:439
 OpLastOperation
//line operation.go2:443
)

//line operation.go2:446
func (o Op) String() string {
	return operatorToString[o]
}

//line operation.go2:451
func (o Op) Category() Category {
	return operatorToCategory[o]
}

//line operation.go2:460
var _ = checkAllOpsInACategoryWithStrings(map[Category]map[Operator]string{
	CatUnknown: {
		OpUnknown: "Unknown",
	},
	CatArithmetic: {
		OpAddition:       "Addition",
		OpSubtraction:    "Subtraction",
		OpMultiplication: "Multiplication",
		OpDivision:       "Division",
		OpModulo:         "Modulo",
	},
	CatAssignment: {
		OpAssign: "Assign",
		OpAlias:  "Alias",
	},
	CatBitwise: {
		OpBitwiseAND: "BitwiseAND",
		OpBitwiseNOT: "BitwiseNOT",
		OpBitwiseOR:  "BitwiseOR",
		OpBitwiseXOR: "BitwiseXOR",
	},
	CatComparison: {
		OpIsNull:             "IsNull",
		OpIsNotNull:          "IsNotNull",
		OpEqual:              "Equal",
		OpNotEqual:           "NotEqual",
		OpLessThan:           "LessThan",
		OpLessThanOrEqual:    "LessThanOrEqual",
		OpGreaterThan:        "GreaterThan",
		OpGreaterThanOrEqual: "GreaterThanOrEqual",
	},
	CatLogical: {
		OpAnd:        "And",
		OpOr:         "Or",
		OpNot:        "Not",
		OpIn:         "In",
		OpNotIn:      "NotIn",
		OpBetween:    "Between",
		OpNotBetween: "NotBetween",
		OpAny:        "Any",
		OpAll:        "All",
		OpSome:       "Some",
		OpExists:     "Exists",
	},
	CatSet: {
		OpSet:       "Set",
		OpList:      "List",
		OpUnion:     "Union",
		OpExcept:    "Except",
		OpIntersect: "Intersect",
	},
	CatString: {
		OpStringCast:   "StringCast",
		OpStringConcat: "StringConcat",
	},
	CatNumeric: {
		OpAbs:        "Abs",
		OpCeiling:    "Ceiling",
		OpFloor:      "Floor",
		OpMax:        "Max",
		OpMin:        "Min",
		OpNumCast:    "NumCast",
		OpRound:      "Round",
		OpSquareRoot: "SquareRoot",
	},
	CatUnary: {
		OpSingleton: "Singleton",
		OpNegate:    "Negate",
	},
	CatOthers: {
		OpCount:            "Count",
		OpLike:             "Like",
		OpNotLike:          "NotLike",
		OpCurrentTimestamp: "CurrentTimestamp",
	},
})

var operatorToString = make(map[Operator]string)
var operatorToCategory = make(map[Operator]Category)
var categoryToOperators = make(map[Category][]Operator)

func checkAllOpsInACategoryWithStrings(catToOps map[Category]map[Operator]string) map[Category]map[Operator]string {
	foundOps := make(map[Operator]Category)
	foundOpStrs := make(map[string]Category)

	var errMsgs []string
	for cat := CatUnknown; cat < CatLastCategory; cat++ {
		opsToStr, found := catToOps[cat]
		if !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Category %d is not in catToOps", cat))
			continue
		}

		for op, opStr := range opsToStr {

			otherCat, alreadyHaveOp := foundOps[op]
			if alreadyHaveOp {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator %s is already in Category %d", opStr, otherCat))
				continue
			}
						foundOps[op] = cat

//line operation.go2:563
   otherCat, alreadyHaveOpStr := foundOpStrs[opStr]
			if alreadyHaveOpStr {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator string %s is already in Category %d", opStr, otherCat))
				continue
			}
			foundOpStrs[opStr] = cat

			categoryToOperators[cat] = append(categoryToOperators[cat], op)
			operatorToCategory[op] = cat
			operatorToString[op] = opStr
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}

	for op := OpUnknown; op < OpLastOperation; op++ {
		if _, found := foundOps[op]; !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Operator QueryParam %d was not found in any category", op))
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}
	return catToOps
}
//line operation.go2:25
func instantiate୦୦NewSimpleOperation୦bool(op Operator, args ...Expression) instantiate୦୦SimpleOperation୦bool {
	return instantiate୦୦SimpleOperation୦bool{
		op:   op,
		args: args,
	}
}

//line operation.go2:30
type instantiate୦୦SimpleOperation୦bool struct {
//line operation.go2:32
 op Operator
	args []Expression
}

//line operation.go2:35
func (o instantiate୦୦SimpleOperation୦bool,) Type() reflect.Type { return o.op.Type() }
func (o instantiate୦୦SimpleOperation୦bool,) String() string {
//line operation.go2:36
 return VisitWithDefaultToStringBuilder(o)
//line operation.go2:36
}
func (o instantiate୦୦SimpleOperation୦bool,) Operator() Operator     { return o.op }
func (o instantiate୦୦SimpleOperation୦bool,) Args() []Expression     { return o.args }
func (o instantiate୦୦SimpleOperation୦bool,) Arg(idx int) Expression { return o.arg(idx) }
func (o instantiate୦୦SimpleOperation୦bool,) arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

//line paths.go2:85
func instantiate୦୦NewSimplePathForVariable୦bool(value bool, variableName string) instantiate୦୦SimplePath୦bool {
	return instantiate୦୦NewSimplePath୦bool(value, NewPathMetadataForVariable(variableName))
}

//line expression.go2:333
func instantiate୦୦NewSimpleConstant୦bool(v bool,

//line expression.go2:333
) instantiate୦୦SimpleConstant୦bool {
	return instantiate୦୦SimpleConstant୦bool{
		value: v,
	}
}
//line operation.go2:25
func instantiate୦୦NewSimpleOperation୦string(op Operator, args ...Expression) instantiate୦୦SimpleOperation୦string {
	return instantiate୦୦SimpleOperation୦string{
		op:   op,
		args: args,
	}
}

//line operation.go2:30
type instantiate୦୦SimpleOperation୦string struct {
//line operation.go2:32
 op Operator
	args []Expression
}

//line operation.go2:35
func (o instantiate୦୦SimpleOperation୦string,) Type() reflect.Type { return o.op.Type() }
func (o instantiate୦୦SimpleOperation୦string,) String() string {
//line operation.go2:36
 return VisitWithDefaultToStringBuilder(o)
//line operation.go2:36
}
func (o instantiate୦୦SimpleOperation୦string,) Operator() Operator     { return o.op }
func (o instantiate୦୦SimpleOperation୦string,) Args() []Expression     { return o.args }
func (o instantiate୦୦SimpleOperation୦string,) Arg(idx int) Expression { return o.arg(idx) }
func (o instantiate୦୦SimpleOperation୦string,) arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

//line paths.go2:85
func instantiate୦୦NewSimplePathForVariable୦string(value string, variableName string) instantiate୦୦SimplePath୦string {
	return instantiate୦୦NewSimplePath୦string(value, NewPathMetadataForVariable(variableName))
}

//line paths.go2:87
type instantiate୦୦SimpleConstant୦bool struct {
//line expression.go2:338
 instantiate୦୦TypedExpression୦bool

	value bool
}

//line expression.go2:342
func (e instantiate୦୦SimpleConstant୦bool,) Type() reflect.Type {
//line expression.go2:342
 return reflect.TypeOf(bool(e.value))
//line expression.go2:342
}
func (e instantiate୦୦SimpleConstant୦bool,) String() string {
	return instantiate୦୦VisitWithBuilder୦lingo୮aTemplates୦string(ToStringBuilder{}, DefaultTemplates(), e)
}
func (e instantiate୦୦SimpleConstant୦bool,) Interface() interface{} { return e.value }

//line expression.go2:346
type instantiate୦୦SimplePath୦string struct {
//line paths.go2:95
 value string
			pm    PathMetadata
}

//line paths.go2:98
func (p instantiate୦୦SimplePath୦string,) Type() reflect.Type { return p.pm.Type() }
func (p instantiate୦୦SimplePath୦string,) String() string {
//line paths.go2:99
 return VisitWithDefaultToStringBuilder(p)
//line paths.go2:99
}
func (p instantiate୦୦SimplePath୦string,) Metadata() PathMetadata { return p.pm }
func (p instantiate୦୦SimplePath୦string,) Root() Path             { return p.pm.Root() }
//line paths.go2:88
func instantiate୦୦NewSimplePath୦string(value string, pm PathMetadata) instantiate୦୦SimplePath୦string {
	return instantiate୦୦SimplePath୦string{
		value: value,
		pm:    pm,
	}
}

//line paths.go2:93
var _ = fmt.Errorf
//line paths.go2:93
var _ = reflect.Append
//line paths.go2:93
var _ = regexp.Compile
//line paths.go2:93
var _ = strconv.AppendBool

//line paths.go2:93
type _ strings.Builder

//line paths.go2:93
var _ = atomic.AddInt32
//line paths.go2:93
var _ = testing.AllocsPerRun
