// Code generated by go2go; DO NOT EDIT.


//line operation.go2:1
package lingo

//line operation.go2:1
import (
//line operation.go2:1
 "fmt"
//line operation.go2:1
 "reflect"
//line operation.go2:1
 "regexp"
//line operation.go2:1
 "strconv"
//line operation.go2:1
 "strings"
//line operation.go2:1
 "sync/atomic"
//line operation.go2:1
 "testing"
//line operation.go2:1
)

//line operation.go2:9
type Operation interface {
	Expression
	Operator() Operator
	Arg(idx int) Expression
	Args() []Expression
}

//line operation.go2:39
func NewPredicateOperation(op Operator, args ...Expression) PredicateOperation {
	return PredicateOperation(instantiate୦୦NewSimpleOperation୦bool(op, args...))
}

//line operation.go2:42
type PredicateOperation instantiate୦୦SimpleOperation୦bool

//line operation.go2:43
func (o PredicateOperation) Type() reflect.Type { return o.Type() }
func (o PredicateOperation) String() string                             { return VisitWithDefaultToStringBuilder(o) }
func (o PredicateOperation) Not() PredicateExpression                   { return NewPredicateOperation(OpNot, o) }
func (o PredicateOperation) Operator() Operator                         { return o.op }
func (o PredicateOperation) Args() []Expression                         { return o.args }
func (o PredicateOperation) Arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

//line operation.go2:57
func NewIsNull(e Expression) BooleanExpression { return NewBooleanOperation(OpIsNull, e) }
func NewIsNotNull(e Expression) BooleanExpression                      { return NewBooleanOperation(OpIsNotNull, e) }
func NewOpEqual(l, r Expression) BooleanExpression                     { return NewBooleanOperation(OpEqual, l, r) }
func NewOpGreaterThan(l, r Expression) BooleanExpression {
//line operation.go2:60
 return NewBooleanOperation(OpGreaterThan, l, r)
//line operation.go2:60
}

func NewBooleanOperation(op Operator, args ...Expression) BooleanOperation {
	return BooleanOperation{
		PredicateOperation: NewPredicateOperation(op, args...),
	}
}

//line operation.go2:67
type BooleanOperation struct {
	PredicateOperation
}

//line operation.go2:70
func (o BooleanOperation) Type() reflect.Type { return o.PredicateOperation.Type() }
func (o BooleanOperation) String() string                             { return VisitWithDefaultToStringBuilder(o) }
func (o BooleanOperation) EqValue(b bool) BooleanExpression {
//line operation.go2:72
 return o.Eq(instantiate୦୦NewSimpleConstant୦bool(b))
//line operation.go2:72
}
func (o BooleanOperation) Eq(e instantiate୦୦TypedExpression୦bool,) BooleanExpression {
//line operation.go2:73
 return NewOpEqual(o, e)
//line operation.go2:73
}

//line operation.go2:77
func NewStringOperation(op Operator, args ...Expression) StringOperation {
	return StringOperation{
		mixin: instantiate୦୦NewSimpleOperation୦string(op, args...),
	}
}

//line operation.go2:82
type StringOperation struct {
	StringExpression
	mixin instantiate୦୦SimpleOperation୦string
}

//line operation.go2:86
func (o StringOperation) Type() reflect.Type { return o.mixin.Type() }
func (o StringOperation) String() string                             { return VisitWithDefaultToStringBuilder(o) }

func (o StringOperation) As(alias instantiate୦୦TypedPath୦string,) StringExpression {
	return NewStringOperation(OpAlias, o, alias)
}
func (o StringOperation) Alias(alias string) StringExpression {
	return o.As(instantiate୦୦NewSimplePathForVariable୦string("", alias))
}

//line operation.go2:98
type Operator interface {
	Type() reflect.Type
}

type Category int

const (
//line operation.go2:106
 CatUnknown Category = iota

//line operation.go2:109
 CatArithmetic

//line operation.go2:112
 CatAssignment

//line operation.go2:115
 CatBitwise

//line operation.go2:119
 CatComparison

//line operation.go2:123
 CatLogical

//line operation.go2:126
 CatSet

//line operation.go2:129
 CatString

//line operation.go2:132
 CatUnary

//line operation.go2:136
 CatOthers

//line operation.go2:139
 CatLastCategory
)

//line operation.go2:143
func (c Category) Operators() []Operator {
	ops := make([]Operator, len(categoryToOperators[c]))
	copy(ops, categoryToOperators[c])
	return ops
}

//line operation.go2:150
type Op int

func (op Op) Type() reflect.Type {
	return reflect.TypeOf(op)
}

const (
//line operation.go2:158
 OpUnknown Op = iota

//line operation.go2:162
 OpAddition
				OpSubtraction
				OpMultiplication
				OpDivision
				OpModulo

//line operation.go2:170
 OpAssign
				OpAlias

//line operation.go2:175
 OpBitwiseAND
				OpBitwiseNOT
				OpBitwiseOR
				OpBitwiseXOR

//line operation.go2:182
 OpIsNull
				OpIsNotNull
				OpEqual
				OpNotEqual
				OpLessThan
				OpLessThanOrEqual
				OpGreaterThan
				OpGreaterThanOrEqual

//line operation.go2:193
 OpAnd
				OpOr
				OpNot
				OpIn
				OpNotIn
				OpBetween
				OpNotBetween
				OpAny
				OpAll
				OpSome
				OpExists

//line operation.go2:207
 OpUnion
				OpExcept
				OpIntersect

//line operation.go2:213
 OpStringConcat

//line operation.go2:217
 OpSingleton
				OpNegate
				OpCurrentTimestamp

//line operation.go2:223
 OpList
				OpCount
				OpLike
				OpNotLike

//line operation.go2:229
 OpLastOperation
//line operation.go2:233
)

//line operation.go2:236
func (o Op) String() string {
	return operatorToString[o]
}

//line operation.go2:241
func (o Op) Category() Category {
	return operatorToCategory[o]
}

//line operation.go2:250
var _ = checkAllOpsInACategoryWithStrings(map[Category]map[Operator]string{
	CatUnknown: {
		OpUnknown: "Unknown",
	},
	CatArithmetic: {
		OpAddition:       "Addition",
		OpSubtraction:    "Subtraction",
		OpMultiplication: "Multiplication",
		OpDivision:       "Division",
		OpModulo:         "Modulo",
	},
	CatAssignment: {
		OpAssign: "Assign",
		OpAlias:  "Alias",
	},
	CatBitwise: {
		OpBitwiseAND: "BitwiseAND",
		OpBitwiseNOT: "BitwiseNOT",
		OpBitwiseOR:  "BitwiseOR",
		OpBitwiseXOR: "BitwiseXOR",
	},
	CatComparison: {
		OpIsNull:             "IsNull",
		OpIsNotNull:          "IsNotNull",
		OpEqual:              "Equal",
		OpNotEqual:           "NotEqual",
		OpLessThan:           "LessThan",
		OpLessThanOrEqual:    "LessThanOrEqual",
		OpGreaterThan:        "GreaterThan",
		OpGreaterThanOrEqual: "GreaterThanOrEqual",
	},
	CatLogical: {
		OpAnd:        "And",
		OpOr:         "Or",
		OpNot:        "Not",
		OpIn:         "In",
		OpNotIn:      "NotIn",
		OpBetween:    "Between",
		OpNotBetween: "NotBetween",
		OpAny:        "Any",
		OpAll:        "All",
		OpSome:       "Some",
		OpExists:     "Exists",
	},
	CatSet: {
		OpUnion:     "Union",
		OpExcept:    "Except",
		OpIntersect: "Intersect",
	},
	CatString: {
		OpStringConcat: "StringConcat",
	},
	CatUnary: {
		OpSingleton: "Singleton",
		OpNegate:    "Negate",
	},
	CatOthers: {
		OpList:             "List",
		OpCount:            "Count",
		OpLike:             "Like",
		OpNotLike:          "NotLike",
		OpCurrentTimestamp: "CurrentTimestamp",
	},
})

var operatorToString = make(map[Operator]string)
var operatorToCategory = make(map[Operator]Category)
var categoryToOperators = make(map[Category][]Operator)

func checkAllOpsInACategoryWithStrings(catToOps map[Category]map[Operator]string) map[Category]map[Operator]string {
	foundOps := make(map[Operator]Category)
	foundOpStrs := make(map[string]Category)

	var errMsgs []string
	for cat := CatUnknown; cat < CatLastCategory; cat++ {
		opsToStr, found := catToOps[cat]
		if !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Category %d is not in catToOps", cat))
			continue
		}

		for op, opStr := range opsToStr {

			otherCat, alreadyHaveOp := foundOps[op]
			if alreadyHaveOp {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator %s is already in Category %d", opStr, otherCat))
				continue
			}
						foundOps[op] = cat

//line operation.go2:341
   otherCat, alreadyHaveOpStr := foundOpStrs[opStr]
			if alreadyHaveOpStr {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator string %s is already in Category %d", opStr, otherCat))
				continue
			}
			foundOpStrs[opStr] = cat

			categoryToOperators[cat] = append(categoryToOperators[cat], op)
			operatorToCategory[op] = cat
			operatorToString[op] = opStr
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}

	for op := OpUnknown; op < OpLastOperation; op++ {
		if _, found := foundOps[op]; !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Operator QueryParam %d was not found in any category", op))
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}
	return catToOps
}
//line operation.go2:16
func instantiate୦୦NewSimpleOperation୦bool(op Operator, args ...Expression) instantiate୦୦SimpleOperation୦bool {
	return instantiate୦୦SimpleOperation୦bool{
		op:   op,
		args: args,
	}
}

//line operation.go2:21
type instantiate୦୦SimpleOperation୦bool struct {
//line operation.go2:23
 op Operator
	args []Expression
}

//line operation.go2:26
func (o instantiate୦୦SimpleOperation୦bool,) Type() reflect.Type { return o.op.Type() }
func (o instantiate୦୦SimpleOperation୦bool,) String() string {
//line operation.go2:27
 return VisitWithDefaultToStringBuilder(o)
//line operation.go2:27
}
func (o instantiate୦୦SimpleOperation୦bool,) Operator() Operator     { return o.op }
func (o instantiate୦୦SimpleOperation୦bool,) Args() []Expression     { return o.args }
func (o instantiate୦୦SimpleOperation୦bool,) Arg(idx int) Expression { return o.arg(idx) }
func (o instantiate୦୦SimpleOperation୦bool,) arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

//line expression.go2:178
func instantiate୦୦NewSimpleConstant୦bool(v bool,

//line expression.go2:178
) instantiate୦୦SimpleConstant୦bool {
	return instantiate୦୦SimpleConstant୦bool{
		value: v,
	}
}
//line operation.go2:16
func instantiate୦୦NewSimpleOperation୦string(op Operator, args ...Expression) instantiate୦୦SimpleOperation୦string {
	return instantiate୦୦SimpleOperation୦string{
		op:   op,
		args: args,
	}
}

//line operation.go2:21
type instantiate୦୦SimpleOperation୦string struct {
//line operation.go2:23
 op Operator
	args []Expression
}

//line operation.go2:26
func (o instantiate୦୦SimpleOperation୦string,) Type() reflect.Type { return o.op.Type() }
func (o instantiate୦୦SimpleOperation୦string,) String() string {
//line operation.go2:27
 return VisitWithDefaultToStringBuilder(o)
//line operation.go2:27
}
func (o instantiate୦୦SimpleOperation୦string,) Operator() Operator     { return o.op }
func (o instantiate୦୦SimpleOperation୦string,) Args() []Expression     { return o.args }
func (o instantiate୦୦SimpleOperation୦string,) Arg(idx int) Expression { return o.arg(idx) }
func (o instantiate୦୦SimpleOperation୦string,) arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

//line paths.go2:85
func instantiate୦୦NewSimplePathForVariable୦string(value string, variableName string) instantiate୦୦SimplePath୦string {
	return instantiate୦୦NewSimplePath୦string(value, NewPathMetadataForVariable(variableName))
}

//line paths.go2:87
type instantiate୦୦SimpleConstant୦bool struct {
//line expression.go2:183
 instantiate୦୦TypedExpression୦bool

	value bool
}

//line expression.go2:187
func (e instantiate୦୦SimpleConstant୦bool,) Type() reflect.Type {
//line expression.go2:187
 return reflect.TypeOf(bool(e.value))
//line expression.go2:187
}
func (e instantiate୦୦SimpleConstant୦bool,) String() string {
	return instantiate୦୦VisitWithBuilder୦lingo୮aTemplates୦string(ToStringBuilder{}, DefaultTemplates(), e)
}
func (e instantiate୦୦SimpleConstant୦bool,) Interface() interface{} { return e.value }

//line expression.go2:191
type instantiate୦୦SimplePath୦string struct {
//line paths.go2:95
 value string

//line paths.go2:96
 pm PathMetadata
}

//line paths.go2:98
func (p instantiate୦୦SimplePath୦string,) Type() reflect.Type { return p.pm.Type() }
func (p instantiate୦୦SimplePath୦string,) String() string {
//line paths.go2:99
 return VisitWithDefaultToStringBuilder(p)
//line paths.go2:99
}
func (p instantiate୦୦SimplePath୦string,) Metadata() PathMetadata { return p.pm }
func (p instantiate୦୦SimplePath୦string,) Root() Path             { return p.pm.Root() }
//line paths.go2:88
func instantiate୦୦NewSimplePath୦string(value string, pm PathMetadata) instantiate୦୦SimplePath୦string {
	return instantiate୦୦SimplePath୦string{
		value: value,
		pm:    pm,
	}
}

//line paths.go2:93
var _ = fmt.Errorf
//line paths.go2:93
var _ = reflect.Append
//line paths.go2:93
var _ = regexp.Compile
//line paths.go2:93
var _ = strconv.AppendBool

//line paths.go2:93
type _ strings.Builder

//line paths.go2:93
var _ = atomic.AddInt32
//line paths.go2:93
var _ = testing.AllocsPerRun
