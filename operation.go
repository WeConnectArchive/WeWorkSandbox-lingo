// Code generated by go2go; DO NOT EDIT.


//line operation.go2:1
package lingo

//line operation.go2:1
import (
//line operation.go2:1
 "encoding/json"
//line operation.go2:1
 "fmt"
//line operation.go2:1
 "reflect"
//line operation.go2:1
 "strconv"
//line operation.go2:1
 "strings"
//line operation.go2:1
 "sync/atomic"
//line operation.go2:1
 "testing"
//line operation.go2:1
)

//line operation.go2:9
type Operation interface {
	Operator() Operator
	Arg(idx int) Expression
	Args() []Expression
}

//line operation.go2:36
func NewPredicateOperation(op Operator, args ...Expression) PredicateOperation {
	return PredicateOperation(instantiate୦୦NewSimpleOperation୦bool(op, args...))
}

//line operation.go2:39
type PredicateOperation instantiate୦୦SimpleOperation୦bool

//line operation.go2:40
func (o PredicateOperation) Type() reflect.Type {
	return o.Type()
}
func (o PredicateOperation) Not() PredicateExpression {
	return NewPredicateOperation(OpNot, o)
}

//line operation.go2:49
func NewBooleanOperation(op Operator, args ...Expression) BooleanOperation {
	return BooleanOperation{
		PredicateOperation: NewPredicateOperation(op, args...),
	}
}

//line operation.go2:54
type BooleanOperation struct {
	PredicateOperation
}

//line operation.go2:57
func (o BooleanOperation) Type() reflect.Type {
	return o.PredicateOperation.Type()
}
func (o BooleanOperation) EqValue(b bool) BooleanExpression {
	return o.Eq(nil)
}
func (o BooleanOperation) Eq(e instantiate୦୦TypedExpression୦bool,) BooleanExpression {
	return NewBooleanOperation(OpEqual, o, e)
}

func NewOpEqual(l, r Expression) BooleanExpression {
	return NewBooleanOperation(OpEqual, l, r)
}
func NewOpGreaterThan(l, r Expression) BooleanExpression {
	return NewBooleanOperation(OpGreaterThan, l, r)
}

//line operation.go2:75
type Operator interface {
	Type() reflect.Type
}

type Category int

const (
//line operation.go2:83
 CatUnknown Category = iota

//line operation.go2:86
 CatArithmetic

//line operation.go2:89
 CatAssignment

//line operation.go2:92
 CatBitwise

//line operation.go2:96
 CatComparison

//line operation.go2:100
 CatLogical

//line operation.go2:103
 CatSet

//line operation.go2:106
 CatString

//line operation.go2:109
 CatUnary

//line operation.go2:113
 CatOthers

//line operation.go2:116
 CatLastCategory
)

//line operation.go2:120
func (c Category) Operators() []Operator {
	ops := make([]Operator, len(categoryToOperators[c]))
	copy(ops, categoryToOperators[c])
	return ops
}

//line operation.go2:127
type Op int

func (op Op) Type() reflect.Type {
	return reflect.TypeOf(op)
}

const (
//line operation.go2:135
 OpUnknown Op = iota

//line operation.go2:139
 OpAddition
				OpSubtraction
				OpMultiplication
				OpDivision
				OpModulo

//line operation.go2:147
 OpAssign
				OpTable
				OpTableAlias
				OpSchema
				OpPath
				OpColumnAlias

//line operation.go2:156
 OpBitwiseAND
				OpBitwiseNOT
				OpBitwiseOR
				OpBitwiseXOR

//line operation.go2:163
 OpIsNull
				OpIsNotNull
				OpEqual
				OpNotEqual
				OpLessThan
				OpLessThanOrEqual
				OpGreaterThan
				OpGreaterThanOrEqual

//line operation.go2:174
 OpAnd
				OpOr
				OpNot
				OpIn
				OpNotIn
				OpBetween
				OpNotBetween
				OpAny
				OpAll
				OpSome
				OpExists

//line operation.go2:188
 OpUnion
				OpExcept
				OpIntersect

//line operation.go2:194
 OpStringConcat

//line operation.go2:198
 OpSingleton
				OpNegate
				OpCurrentTimestamp

//line operation.go2:204
 OpList
				OpCount
				OpLike
				OpNotLike

//line operation.go2:210
 OpLastOperation
//line operation.go2:214
)

//line operation.go2:217
func (o Op) String() string {
	return operatorToString[o]
}

//line operation.go2:222
func (o Op) Category() Category {
	return operatorToCategory[o]
}

//line operation.go2:231
var _ = checkAllOpsInACategoryWithStrings(map[Category]map[Operator]string{
	CatUnknown: {
		OpUnknown: "Unknown",
	},
	CatArithmetic: {
		OpAddition:       "Addition",
		OpSubtraction:    "Subtraction",
		OpMultiplication: "Multiplication",
		OpDivision:       "Division",
		OpModulo:         "Modulo",
	},
	CatAssignment: {
		OpAssign:      "Assign",
		OpTable:       "Table",
		OpTableAlias:  "TableAlias",
		OpSchema:      "Schema",
		OpPath:        "Path",
		OpColumnAlias: "ColumnAlias",
	},
	CatBitwise: {
		OpBitwiseAND: "BitwiseAND",
		OpBitwiseNOT: "BitwiseNOT",
		OpBitwiseOR:  "BitwiseOR",
		OpBitwiseXOR: "BitwiseXOR",
	},
	CatComparison: {
		OpIsNull:             "IsNull",
		OpIsNotNull:          "IsNotNull",
		OpEqual:              "Equal",
		OpNotEqual:           "NotEqual",
		OpLessThan:           "LessThan",
		OpLessThanOrEqual:    "LessThanOrEqual",
		OpGreaterThan:        "GreaterThan",
		OpGreaterThanOrEqual: "GreaterThanOrEqual",
	},
	CatLogical: {
		OpAnd:        "And",
		OpOr:         "Or",
		OpNot:        "Not",
		OpIn:         "In",
		OpNotIn:      "NotIn",
		OpBetween:    "Between",
		OpNotBetween: "NotBetween",
		OpAny:        "Any",
		OpAll:        "All",
		OpSome:       "Some",
		OpExists:     "Exists",
	},
	CatSet: {
		OpUnion:     "Union",
		OpExcept:    "Except",
		OpIntersect: "Intersect",
	},
	CatString: {
		OpStringConcat: "StringConcat",
	},
	CatUnary: {
		OpSingleton: "Singleton",
		OpNegate:    "Negate",
	},
	CatOthers: {
		OpList:             "List",
		OpCount:            "Count",
		OpLike:             "Like",
		OpNotLike:          "NotLike",
		OpCurrentTimestamp: "CurrentTimestamp",
	},
})

var operatorToString = make(map[Operator]string)
var operatorToCategory = make(map[Operator]Category)
var categoryToOperators = make(map[Category][]Operator)

func checkAllOpsInACategoryWithStrings(catToOps map[Category]map[Operator]string) map[Category]map[Operator]string {
	foundOps := make(map[Operator]Category)
	foundOpStrs := make(map[string]Category)

	var errMsgs []string
	for cat := CatUnknown; cat < CatLastCategory; cat++ {
		opsToStr, found := catToOps[cat]
		if !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Category %d is not in catToOps", cat))
			continue
		}

		for op, opStr := range opsToStr {

			otherCat, alreadyHaveOp := foundOps[op]
			if alreadyHaveOp {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator %s is already in Category %d", opStr, otherCat))
				continue
			}
						foundOps[op] = cat

//line operation.go2:326
   otherCat, alreadyHaveOpStr := foundOpStrs[opStr]
			if alreadyHaveOpStr {
				errMsgs = append(errMsgs, fmt.Sprintf("Operator string %s is already in Category %d", opStr, otherCat))
				continue
			}
			foundOpStrs[opStr] = cat

			categoryToOperators[cat] = append(categoryToOperators[cat], op)
			operatorToCategory[op] = cat
			operatorToString[op] = opStr
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}

	for op := OpUnknown; op < OpLastOperation; op++ {
		if _, found := foundOps[op]; !found {
			errMsgs = append(errMsgs, fmt.Sprintf("Operator QueryParam %d was not found in any category", op))
		}
	}
	if len(errMsgs) > 0 {
		panic(strings.Join(errMsgs, "\n"))
	}
	return catToOps
}
//line operation.go2:15
func instantiate୦୦NewSimpleOperation୦bool(op Operator, args ...Expression) instantiate୦୦SimpleOperation୦bool {
	return instantiate୦୦SimpleOperation୦bool{
		op:   op,
		args: args,
	}
}

//line operation.go2:20
type instantiate୦୦SimpleOperation୦bool struct {
//line operation.go2:22
 op Operator
	args []Expression
}

//line operation.go2:25
func (o instantiate୦୦SimpleOperation୦bool,) Type() reflect.Type { return o.op.Type() }
func (o instantiate୦୦SimpleOperation୦bool,) Operator() Operator                         { return o.op }
func (o instantiate୦୦SimpleOperation୦bool,) Args() []Expression                         { return o.args }
func (o instantiate୦୦SimpleOperation୦bool,) Arg(idx int) Expression {
	if idx >= len(o.args) {
		return nil
	}
	return o.args[idx]
}

//line operation.go2:33
var _ = json.Compact
//line operation.go2:33
var _ = fmt.Errorf
//line operation.go2:33
var _ = reflect.Append
//line operation.go2:33
var _ = strconv.AppendBool

//line operation.go2:33
type _ strings.Builder

//line operation.go2:33
var _ = atomic.AddInt32
//line operation.go2:33
var _ = testing.AllocsPerRun
