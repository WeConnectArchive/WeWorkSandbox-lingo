// Code generated by go2go; DO NOT EDIT.


//line paths.go2:1
package lingo

//line paths.go2:1
import (
//line paths.go2:1
 "fmt"
//line paths.go2:1
 "reflect"
//line paths.go2:1
 "regexp"
//line paths.go2:1
 "strconv"
//line paths.go2:1
 "strings"
//line paths.go2:1
 "sync/atomic"
//line paths.go2:1
 "testing"
//line paths.go2:1
)

//line paths.go2:8
type PathType int

func (p PathType) Type() reflect.Type {
	return reflect.TypeOf(p)
}

const (
	Unknown PathType = iota

	ArrayValue
	ArrayValueConstant
	CollectionAny
	Delegate
	ListValue
	ListValueConstant
	MapValue
	MapValueConstant
	Property
	Variable
)

func NewPathMetadataForVariable(varName string) PathMetadata {
//line paths.go2:29
 return NewPathMetadata(Variable, varName, nil)
//line paths.go2:29
}
func NewPathMetadataForProperty(propName string, parent Path) PathMetadata {
//line paths.go2:30
 return NewPathMetadata(Property, propName, parent)
//line paths.go2:30
}
func NewPathMetadata(pt PathType, element interface{}, parent Path) PathMetadata {
	var root Path
	if parent != nil {
		root = parent.Root()
	}
	return PathMetadata{
		pathType: pt,
		root:     root,
		parent:   parent,
		element:  element,
	}
}

//line paths.go2:43
type PathMetadata struct {
	pathType PathType
	root     Path
	parent   Path
	element  interface{}
}

//line paths.go2:49
func (pm PathMetadata) Type() reflect.Type { return reflect.TypeOf(pm.pathType) }
func (pm PathMetadata) IsZero() bool {
	return pm == PathMetadata{}
}
func (pm PathMetadata) PathType() PathType { return pm.pathType }
func (pm PathMetadata) Parent() Path       { return pm.parent }
func (pm PathMetadata) Root() Path         { return pm.root }
func (pm PathMetadata) IsRoot() bool {
	return pm.Parent() == nil || (pm.PathType() == Delegate && pm.Parent().Metadata().IsRoot())
}
func (pm PathMetadata) Elem() interface{} { return pm.element }
func (pm PathMetadata) Name() string {
	switch pm.pathType {
	case Variable, Property:
		return pm.Elem().(string)
	}
	panic(fmt.Sprintf("name property not available for path type %d, must be accessed with Element()", pm.pathType))
}

//line paths.go2:70
type Path interface {
	Expression
	Metadata() PathMetadata
	Root() Path
}

//line paths.go2:105
func NewBoolPath(p instantiate୦୦SimplePath୦bool,) BoolPath {
	return BoolPath{
		mixin: p,
	}
}

//line paths.go2:110
type BoolPath struct {
	mixin instantiate୦୦SimplePath୦bool
}

//line paths.go2:113
func (p BoolPath) Type() reflect.Type { return p.mixin.Type() }
func (p BoolPath) String() string                          { return VisitWithDefaultToStringBuilder(p) }
func (p BoolPath) Metadata() PathMetadata                  { return p.mixin.Metadata() }
func (p BoolPath) Root() Path                              { return p.mixin.Root() }

func (p BoolPath) EqValue(v bool) BooleanExpression {
	return p.Eq(instantiate୦୦NewSimpleConstant୦bool(v))
}
func (p BoolPath) Eq(v instantiate୦୦TypedExpression୦bool,) BooleanExpression {
	return NewOpEqual(p, v)
}

//line paths.go2:157
func NewStringPath(p instantiate୦୦SimplePath୦string,) StringPath {
	return StringPath{
		mixin: p,
	}
}

//line paths.go2:162
type StringPath struct {
	StringExpression
	mixin instantiate୦୦SimplePath୦string
}

//line paths.go2:165
var _ = fmt.Errorf
//line paths.go2:165
var _ = reflect.Append
//line paths.go2:165
var _ = regexp.Compile
//line paths.go2:165
var _ = strconv.AppendBool

//line paths.go2:165
type _ strings.Builder

//line paths.go2:165
var _ = atomic.AddInt32
//line paths.go2:165
var _ = testing.AllocsPerRun
