// Code generated by go2go; DO NOT EDIT.


//line syntax.go2:1
package lingo

//line syntax.go2:1
import (
//line syntax.go2:1
 "fmt"
//line syntax.go2:1
 "reflect"
//line syntax.go2:1
 "regexp"
//line syntax.go2:1
 "strconv"
//line syntax.go2:1
 "strings"
//line syntax.go2:1
 "sync/atomic"
//line syntax.go2:1
 "testing"
//line syntax.go2:1
)

//line syntax.go2:9
var numRegex = regexp.MustCompile(`{(\d+)}`)

//line syntax.go2:13
func NewSyntax(exp string) Syntax {
	args := numRegex.FindAllString(exp, -1)

	if len(args) == 0 {
		return Syntax{expression: exp}
	}

	var set = make(map[string]struct{})

	for _, arg := range args {
		if _, alreadyFound := set[arg]; alreadyFound {
			panic(fmt.Errorf("syntax expression '%s' has a duplicate index argument '%s'", exp, arg))
		}
		set[arg] = struct{}{}
	}

	for idx := 0; idx < len(args); idx++ {
		argVal := fmt.Sprintf("{%d}", idx)
		if _, ok := set[argVal]; !ok {
			panic(fmt.Errorf("syntax expression '%s' is missing an index argument '%s'", exp, argVal))
		}
	}
	return Syntax{
		expression: exp,
		argCount:   len(args),
	}
}

//line syntax.go2:43
type Syntax struct {
	expression string
	argCount   int
}

func (s Syntax) String() string { return s.expression }
func (s Syntax) ArgCount() int  { return s.argCount }

func (s Syntax) Replace(replaceFunc func(idx int) string) string {
	return numRegex.ReplaceAllStringFunc(s.expression,
		func(s string) string {
			value := s[1 : len(s)-1]
			idx, _ := strconv.Atoi(value)
			return replaceFunc(idx)
		},
	)
}

type Templates map[Operator]Syntax

func DefaultTemplates() Templates {
	var t = make(Templates, len(defaultTemplate))
	for k, v := range defaultTemplate {
		t[k] = v
	}
	return t
}

var defaultTemplate = requireSyntaxForEveryOperator(Templates{
			Property: NewSyntax("{0}.{1}"),
			Variable: NewSyntax("{0}"),
			Delegate: NewSyntax("{0}"),

//line syntax.go2:77
  OpAddition:       NewSyntax("{0} + {1}"),
			OpSubtraction:    NewSyntax("{0} - {1}"),
			OpMultiplication: NewSyntax("{0} * {1}"),
			OpDivision:       NewSyntax("{0} / {1}"),
			OpModulo:         NewSyntax("{0} % {1}"),

//line syntax.go2:84
  OpAssign: NewSyntax("{0} = {1}"),
			OpAlias:  NewSyntax("{0} AS {1}"),

//line syntax.go2:88
  OpBitwiseAND: NewSyntax("{0} & {1}"),
			OpBitwiseOR:  NewSyntax("{0} | {1}"),
			OpBitwiseXOR: NewSyntax("{0} ^ {1}"),
			OpBitwiseNOT: NewSyntax("~{0}"),

//line syntax.go2:94
  OpEqual:              NewSyntax("{0} = {1}"),
			OpNotEqual:           NewSyntax("{0} <> {1}"),
			OpLessThan:           NewSyntax("{0} < {1}"),
			OpGreaterThan:        NewSyntax("{0} > {1}"),
			OpLessThanOrEqual:    NewSyntax("{0} <= {1}"),
			OpGreaterThanOrEqual: NewSyntax("{0} >= {1}"),
			OpIsNull:             NewSyntax("{0} IS NULL"),
			OpIsNotNull:          NewSyntax("{0} IS NOT NULL"),

//line syntax.go2:104
 OpAnd:        NewSyntax("{0} AND {1}"),
			OpOr:         NewSyntax("{0} OR {1}"),
			OpNot:        NewSyntax("NOT {0}"),
			OpIn:         NewSyntax("{0} IN {1}"),
			OpNotIn:      NewSyntax("{0} NOT IN {1}"),
			OpBetween:    NewSyntax("{0} BETWEEN {1} AND {2}"),
			OpNotBetween: NewSyntax("{0} NOT BETWEEN {1} AND {2}"),
			OpAny:        NewSyntax("ANY ({0})"),
			OpAll:        NewSyntax("ALL ({0})"),
			OpSome:       NewSyntax("SOME ({0})"),
			OpExists:     NewSyntax("EXISTS ({0})"),

//line syntax.go2:117
 OpUnion:     NewSyntax("{0} UNION {1}"),
			OpExcept:    NewSyntax("{0} EXCEPT {1}"),
			OpIntersect: NewSyntax("{0} INTERSECT {1}"),

//line syntax.go2:122
 OpStringConcat: NewSyntax("CONCAT({0}, {1})"),

//line syntax.go2:125
 OpSingleton: NewSyntax("{0}"),
			OpNegate:    NewSyntax("-{0}"),

//line syntax.go2:129
 OpList:             NewSyntax("{0}, {1}"),
			OpCount:            NewSyntax("COUNT({0})"),
			OpLike:             NewSyntax("{0} LIKE {1}"),
			OpNotLike:          NewSyntax("{0} NOT LIKE {1}"),
			OpCurrentTimestamp: NewSyntax("CURRENT_TIMESTAMP"),
})

func requireSyntaxForEveryOperator(ops Templates) Templates {
	for op := OpUnknown + 1; op < OpLastOperation; op++ {
		_, found := ops[op]
		if !found {
			panic(fmt.Sprintf("Operator %d does not have a default Syntax", op))
		}
	}
	return ops
}

//line syntax.go2:144
var _ = fmt.Errorf
//line syntax.go2:144
var _ = reflect.Append
//line syntax.go2:144
var _ = regexp.Compile
//line syntax.go2:144
var _ = strconv.AppendBool

//line syntax.go2:144
type _ strings.Builder

//line syntax.go2:144
var _ = atomic.AddInt32
//line syntax.go2:144
var _ = testing.AllocsPerRun
