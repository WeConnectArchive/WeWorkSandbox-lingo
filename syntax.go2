package lingo

import (
	"fmt"
	"regexp"
	"strconv"
)

var numRegex = regexp.MustCompile(`{(\d+)}`)

// NewSyntax will check the positional argument expression and will panic if it doesnt meet
// requirements. This should only be used during init code.
func NewSyntax(exp string) Syntax {
	args := numRegex.FindAllString(exp, -1)
	// If there are no arguments, nothing to check.
	if len(args) == 0 {
		return Syntax{expression: exp}
	}
	// TODO - Replace all of this with the new Gv2 generic slices functions
	var set = make(map[string]struct{})
	// Add all args to the set, checking for duplicates
	for _, arg := range args {
		if _, alreadyFound := set[arg]; alreadyFound {
			panic(fmt.Errorf("syntax expression '%s' has a duplicate index argument '%s'", exp, arg))
		}
		set[arg] = struct{}{}
	}
	// Check each arg starting from zero to ensure each in order exists.
	for idx := 0; idx < len(args); idx++ {
		argVal := fmt.Sprintf("{%d}", idx)
		if _, ok := set[argVal]; !ok {
			panic(fmt.Errorf("syntax expression '%s' is missing an index argument '%s'", exp, argVal))
		}
	}
	return Syntax{
		expression: exp,
		argCount:   len(args),
	}
}

// Syntax holds the expression used to expand the Expressions into strings by positional arguments.
// Note: The Syntax type expects `{\d+}` as the basic positional token.
type Syntax struct {
	expression string
	argCount   int
}

func (s Syntax) String() string { return s.expression }
func (s Syntax) ArgCount() int  { return s.argCount }

func (s Syntax) Replace(replaceFunc func(idx int) string) string {
	return numRegex.ReplaceAllStringFunc(s.expression,
		func(s string) string {
			value := s[1 : len(s)-1] // We know its surrounded in `{` and `}`
			idx, _ := strconv.Atoi(value)
			return replaceFunc(idx)
		},
	)
}

type Templates map[Operator]Syntax

func DefaultTemplates() Templates {
	var t = make(Templates, len(defaultTemplate))
	for k, v := range defaultTemplate {
		t[k] = v
	}
	return t
}

var defaultTemplate = requireSyntaxForEveryOperator(Templates{
	Property: NewSyntax("{0}.{1}"),
	Variable: NewSyntax("{0}"),
	Delegate: NewSyntax("{0}"),

	// CatArithmetic
	OpAddition:       NewSyntax("{0} + {1}"),
	OpSubtraction:    NewSyntax("{0} - {1}"),
	OpMultiplication: NewSyntax("{0} * {1}"),
	OpDivision:       NewSyntax("{0} / {1}"),
	OpModulo:         NewSyntax("{0} % {1}"),

	// CatAssignment
	OpAssign: NewSyntax("{0} = {1}"),
	OpAlias:  NewSyntax("{0} AS {1}"),

	// CatBitwise
	OpBitwiseAND: NewSyntax("{0} & {1}"),
	OpBitwiseOR:  NewSyntax("{0} | {1}"),
	OpBitwiseXOR: NewSyntax("{0} ^ {1}"),
	OpBitwiseNOT: NewSyntax("~{0}"),

	// CatComparison
	OpEqual:              NewSyntax("{0} = {1}"),
	OpNotEqual:           NewSyntax("{0} <> {1}"),
	OpLessThan:           NewSyntax("{0} < {1}"),
	OpGreaterThan:        NewSyntax("{0} > {1}"),
	OpLessThanOrEqual:    NewSyntax("{0} <= {1}"),
	OpGreaterThanOrEqual: NewSyntax("{0} >= {1}"),
	OpIsNull:             NewSyntax("{0} IS NULL"),
	OpIsNotNull:          NewSyntax("{0} IS NOT NULL"),

	// CatLogical
	OpAnd:        NewSyntax("{0} AND {1}"),
	OpOr:         NewSyntax("{0} OR {1}"),
	OpNot:        NewSyntax("NOT {0}"),
	OpIn:         NewSyntax("{0} IN {1}"),
	OpNotIn:      NewSyntax("{0} NOT IN {1}"),
	OpBetween:    NewSyntax("{0} BETWEEN {1} AND {2}"),
	OpNotBetween: NewSyntax("{0} NOT BETWEEN {1} AND {2}"),
	OpAny:        NewSyntax("ANY ({0})"),
	OpAll:        NewSyntax("ALL ({0})"),
	OpSome:       NewSyntax("SOME ({0})"),
	OpExists:     NewSyntax("EXISTS ({0})"),

	// CatSet
	OpUnion:     NewSyntax("{0} UNION {1}"),
	OpExcept:    NewSyntax("{0} EXCEPT {1}"),
	OpIntersect: NewSyntax("{0} INTERSECT {1}"),

	// CatString
	OpStringConcat: NewSyntax("CONCAT({0}, {1})"),

	// CatUnary
	OpSingleton: NewSyntax("{0}"),
	OpNegate:    NewSyntax("-{0}"),

	// ???
	OpList:             NewSyntax("{0}, {1}"),
	OpCount:            NewSyntax("COUNT({0})"),
	OpLike:             NewSyntax("{0} LIKE {1}"),
	OpNotLike:          NewSyntax("{0} NOT LIKE {1}"),
	OpCurrentTimestamp: NewSyntax("CURRENT_TIMESTAMP"),
})

func requireSyntaxForEveryOperator(ops Templates) Templates {
	for op := OpUnknown + 1; op < OpLastOperation; op++ {
		_, found := ops[op]
		if !found {
			panic(fmt.Sprintf("Operator %d does not have a default Syntax", op))
		}
	}
	return ops
}
