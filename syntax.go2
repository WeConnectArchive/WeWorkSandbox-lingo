package lingo

import (
	"fmt"
	"strings"
)

type Syntax string

func Replace(s Syntax, args ...interface{}) string {
	result := string(s)
	for idx := range args {
		arg := args[idx]
		// TODO accept function here for Expression types
		strArg := fmt.Sprintf("%s", arg)
		result = strings.Replace(result, fmt.Sprintf("{%d}", idx), strArg, -1)
	}
	return result
}

type Template map[Operator]Syntax

func DefaultTemplate() Template {
	var t = make(Template, len(defaultTemplate))
	for k, v := range defaultTemplate {
		t[k] = v
	}
	return t
}

var defaultTemplate = requireSyntaxForEveryOperator(Template{
	Property: "{0}.{1}",
	Variable: "{0}",
	Delegate: "{0}",

	// CatArithmetic
	OpAddition:       "{0} + {1}",
	OpSubtraction:    "{0} - {1}",
	OpMultiplication: "{0} * {1}",
	OpDivision:       "{0} / {1}",
	OpModulo:         "{0} % {1}",

	// CatAssignment
	OpAssign:      "{0} = {1}",
	OpTable:       "{1}", // {0} & {1} only
	OpTableAlias:  "{1} AS {2}",
	OpSchema:      "", // {0} only
	OpPath:        "{0}.{1}",
	OpColumnAlias: "{0}.{1} AS {2}",

	// CatBitwise
	OpBitwiseAND: "{0} & {1}",
	OpBitwiseOR:  "{0} | {1}",
	OpBitwiseXOR: "{0} ^ {1}",
	OpBitwiseNOT: "~{0}",

	// CatComparison
	OpEqual:              "{0} = {1}",
	OpNotEqual:           "{0} <> {1}",
	OpLessThan:           "{0} < {1}",
	OpGreaterThan:        "{0} > {1}",
	OpLessThanOrEqual:    "{0} <= {1}",
	OpGreaterThanOrEqual: "{0} >= {1}",
	OpIsNull:             "{0} IS NULL",
	OpIsNotNull:          "{0} IS NOT NULL",

	// CatLogical
	OpAnd:        "{0} AND {1}",
	OpOr:         "{0} OR {1}",
	OpNot:        "NOT {0}",
	OpIn:         "{0} IN {1}",
	OpNotIn:      "{0} NOT IN {1}",
	OpBetween:    "{0} BETWEEN {1} AND {2}",
	OpNotBetween: "{0} NOT BETWEEN {1} AND {2}",
	OpAny:        "ANY ({0})",
	OpAll:        "ALL ({0})",
	OpSome:       "SOME ({0})",
	OpExists:     "EXISTS ({0})",

	// CatSet
	OpUnion:     "{0} UNION {1}",
	OpExcept:    "{0} EXCEPT {1}",
	OpIntersect: "{0} INTERSECT {1}",

	// CatString
	OpStringConcat: "CONCAT({0}, {1})",

	// CatUnary
	OpSingleton: "{0}",
	OpNegate:    "-{0}",

	// ???
	OpList:             "{0}, {1}",
	OpCount:            "COUNT({0})",
	OpLike:             "{0} LIKE {1}",
	OpNotLike:          "{0} NOT LIKE {1}",
	OpCurrentTimestamp: "CURRENT_TIMESTAMP",
})

func requireSyntaxForEveryOperator(ops Template) Template {
	for op := OpUnknown + 1; op < OpLastOperation; op++ {
		_, found := ops[op]
		if !found {
			panic(fmt.Sprintf("Operator %d does not have a default Syntax", op))
		}
	}
	return ops
}
