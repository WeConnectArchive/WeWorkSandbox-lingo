package lingo

import (
	"fmt"
	"regexp"
	"strconv"
)

var numRegex = regexp.MustCompile(`{(\d+)}`)

// NewSyntax will check the positional argument expression and will panic if it doesnt meet
// requirements. This should only be used during init code.
func NewSyntax(exp string) Syntax {
	args := numRegex.FindAllString(exp, -1)
	// If there are no arguments, nothing to check.
	if len(args) == 0 {
		return Syntax{expression: exp}
	}
	// TODO - Replace all of this with the new Gv2 generic slices functions
	var set = make(map[string]struct{})
	// Add all args to the set, checking for duplicates
	for _, arg := range args {
		if _, alreadyFound := set[arg]; alreadyFound {
			panic(fmt.Errorf("syntax expression '%s' has a duplicate index argument '%s'", exp, arg))
		}
		set[arg] = struct{}{}
	}
	// Check each arg starting from zero to ensure each in order exists.
	for idx := 0; idx < len(args); idx++ {
		argVal := fmt.Sprintf("{%d}", idx)
		if _, ok := set[argVal]; !ok {
			panic(fmt.Errorf("syntax expression '%s' is missing an index argument '%s'", exp, argVal))
		}
	}
	return Syntax{
		expression: exp,
		argCount:   len(args),
	}
}

// Syntax holds the expression used to expand the Expressions into strings by positional arguments.
// Note: The Syntax type expects `{\d+}` as the basic positional token.
type Syntax struct {
	expression string
	argCount   int
}

func (s Syntax) String() string { return s.expression }
func (s Syntax) ArgCount() int  { return s.argCount }

func (s Syntax) Replace(replaceFunc func(idx int) string) string {
	return numRegex.ReplaceAllStringFunc(s.expression,
		func(s string) string {
			value := s[1 : len(s)-1] // We know its surrounded in `{` and `}`
			idx, _ := strconv.Atoi(value)
			return replaceFunc(idx)
		},
	)
}

func DefaultTemplates() Templates {
	var t = make(Templates, len(defaultTemplate))
	for k, v := range defaultTemplate {
		t[k] = v
	}
	return t
}

type Templates map[Operator]Syntax

var escape = "ESCAPEVALUE" // TODO
var defaultTemplate = requireSyntaxForEveryOperator(Templates{
	Property: NewSyntax("{0}.{1}"),
	Variable: NewSyntax("{0}"),
	Delegate: NewSyntax("{0}"),

	// CatArithmetic
	OpAddition:       NewSyntax("{0} + {1}"),
	OpSubtraction:    NewSyntax("{0} - {1}"),
	OpMultiplication: NewSyntax("{0} * {1}"),
	OpDivision:       NewSyntax("{0} / {1}"),
	OpModulo:         NewSyntax("{0} % {1}"),

	// CatAssignment
	OpAssign: NewSyntax("{0} = {1}"),
	OpAlias:  NewSyntax("{0} AS {1}"),

	// CatBitwise
	OpBitwiseAND: NewSyntax("{0} & {1}"),
	OpBitwiseOR:  NewSyntax("{0} | {1}"),
	OpBitwiseXOR: NewSyntax("{0} ^ {1}"),
	OpBitwiseNOT: NewSyntax("~{0}"),

	// CatComparison
	OpEqual:              NewSyntax("{0} = {1}"),
	OpNotEqual:           NewSyntax("{0} <> {1}"),
	OpLessThan:           NewSyntax("{0} < {1}"),
	OpGreaterThan:        NewSyntax("{0} > {1}"),
	OpLessThanOrEqual:    NewSyntax("{0} <= {1}"),
	OpGreaterThanOrEqual: NewSyntax("{0} >= {1}"),
	OpIsNull:             NewSyntax("{0} IS NULL"),
	OpIsNotNull:          NewSyntax("{0} IS NOT NULL"),

	// CatLogical
	OpAnd:        NewSyntax("{0} AND {1}"),
	OpOr:         NewSyntax("{0} OR {1}"),
	OpNot:        NewSyntax("NOT {0}"),
	OpIn:         NewSyntax("{0} IN {1}"),
	OpNotIn:      NewSyntax("{0} NOT IN {1}"),
	OpBetween:    NewSyntax("{0} BETWEEN {1} AND {2}"),
	OpNotBetween: NewSyntax("{0} NOT BETWEEN {1} AND {2}"),
	OpAny:        NewSyntax("ANY ({0})"),
	OpAll:        NewSyntax("ALL ({0})"),
	OpSome:       NewSyntax("SOME ({0})"),
	OpExists:     NewSyntax("EXISTS ({0})"),

	// CatSet
	OpSet:       NewSyntax("{0}, {1}"),
	OpList:      NewSyntax("{0}, {1}"),
	OpUnion:     NewSyntax("{0} UNION {1}"),
	OpExcept:    NewSyntax("{0} EXCEPT {1}"),
	OpIntersect: NewSyntax("{0} INTERSECT {1}"),

	// CatString
	OpStringCast:           NewSyntax("STR({0})"),
	OpStringConcat:         NewSyntax("{0} || {1}"),
	OpCharAt:               NewSyntax("CAST(SUBSTR({0}, {1}, 1) AS CHAR)"),
	OpStringContains:       NewSyntax("{0} LIKE {%1%} ESCAPE '" + escape + "'"),
	OpStringContainsFold:   NewSyntax("{0l} LIKE {%%1%%} ESCAPE '" + escape + "'"),
	OpEqualsFold:           NewSyntax("{0l} = {1l}"),
	OpHasPrefix:            NewSyntax("{0} LIKE {1%} ESCAPE '" + escape + "'"),
	OpHasPrefixFold:        NewSyntax("{0l} LIKE {1%%} ESCAPE '" + escape + "'"),
	OpHasSuffix:            NewSyntax("{0} LIKE {%1} ESCAPE '" + escape + "'"),
	OpHasSuffixFold:        NewSyntax("{0l} LIKE {%%1} ESCAPE '" + escape + "'"),
	OpIndexOf:              NewSyntax("LOCATE({1},{0})-1"),
	OpIndexOfN:             NewSyntax("LOCATE({1},{0},{2+'1's})-1"),
	OpStringIsEmpty:        NewSyntax("LENGTH({0}) = 0"),
	OpStringLength:         NewSyntax("LENGTH({0})"),
	OpStringLike:           NewSyntax("{0} LIKE {1} ESCAPE '" + escape + "'"),
	OpStringLikeFold:       NewSyntax("{0l} LIKE {1l}"),
	OpStringLikeEscape:     NewSyntax("{0} LIKE {1} ESCAPE '{2s}'"),
	OpStringLikeFoldEscape: NewSyntax("{0l} LIKE {1l} ESCAPE '{2s}'"),
	OpStringLocate:         NewSyntax("LOCATE({0}, {1})"),
	OpStringLocate2:        NewSyntax("LOCATE({0}, {1}, {2s})"),
	OpStringLower:          NewSyntax("LOWER({0})"),
	OpStringMatches:        NewSyntax("{0} REGEXP {1}"),
	OpStringSubstring:      NewSyntax("SUBSTR({0},{1s}+1)"),
	OpStringSubstring2:     NewSyntax("SUBSTR({0},{1+'1's},{2-1s})"),
	OpStringTrim:           NewSyntax("TRIM({0})"),
	OpStringToUpper:        NewSyntax("UPPER({0})"),

	// CatNumeric
	OpAbs:        NewSyntax("ABS({0})"),
	OpCeiling:    NewSyntax("CEIL({0}"),
	OpFloor:      NewSyntax("FLOOR({0})"),
	OpMax:        NewSyntax("MAX({0}, {1})"),
	OpMin:        NewSyntax("MIN({0}, {1})"),
	OpNumCast:    NewSyntax("CAST({0}, {1})"),
	OpRound:      NewSyntax("ROUND({0})"),
	OpSquareRoot: NewSyntax("SQRT({0})"),

	// CatUnary
	OpSingleton: NewSyntax("{0}"),
	OpNegate:    NewSyntax("-{0}"),

	// ???
	OpCount:            NewSyntax("COUNT({0})"),
	OpLike:             NewSyntax("{0} LIKE {1}"),
	OpNotLike:          NewSyntax("{0} NOT LIKE {1}"),
	OpCurrentTimestamp: NewSyntax("CURRENT_TIMESTAMP"),
})

func requireSyntaxForEveryOperator(ops Templates) Templates {
	for op := OpUnknown + 1; op < OpLastOperation; op++ {
		_, found := ops[op]
		if !found {
			panic(fmt.Sprintf("Operator %s(%d) does not have a default Syntax", op, op))
		}
	}
	return ops
}
