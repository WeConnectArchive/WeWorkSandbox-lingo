package lingo

import (
	"fmt"
	"strings"
)

type TypedBuilder[C, T any] interface {
	Visit(ctx C, e Expression) T
}

func VisitWithBuilder[C, T any](b TypedBuilder[C, T], buildCtx C, e Expression) T {
	return b.Visit(buildCtx, e)
}

type ParamMetadata struct {
	e ParamExpression
	v interface{}
}

type ourFlagPos int
type FlagPos ourFlagPos

const (
	PosWith FlagPos = FlagPos(iota)
	PosStart
	PosStartOverride
	PosAfterSelect
	PosAfterProjection
	PosBeforeFilters
	PosAfterFilters
	PosBeforeGroupBy
	PosAfterGroupBy
	PosBeforeHaving
	PosAfterHaving
	PosBeforeOrder
	PosAfterOrder
	PosEnd
)

// NewQueryFlag
func NewQueryFlag(pos FlagPos, flag Expression) QueryFlag {
	return QueryFlag{
		pos:  pos,
		flag: flag,
	}
}

type QueryFlag struct {
	pos  FlagPos
	flag Expression
}

func (qf QueryFlag) Position() FlagPos {
	return qf.pos
}
func (qf QueryFlag) Flag() Expression {
	return qf.flag
}

// QueryMetadata
type QueryMetadata interface {
	ShouldValidate(validate bool)

	AddGroupBy(e Expression)

	AddHaving(e PredicateExpression)

	AddJoin(jt JoinType, e Expression)
	AddJoinFlag(jf JoinFlag)
	AddJoinCondition(e PredicateExpression)
	Joins() []JoinExpression

	AddOrderBy(o Order)
	OrderBy() []Order
	ClearOrderBy()

	AddFlag(qf QueryFlag)
	HasFlag(qf QueryFlag) bool
	Flags() []QueryFlag
	RemoveFlag(qf QueryFlag)

	AddWhere(e PredicateExpression)
	Where() PredicateExpression
	ClearWhere()

	GroupBy() []Expression

	Having() PredicateExpression

	SetModifiers(m QueryModifiers)
	SetOffset(l int64)
	SetLimit(l int64)
	Modifiers() QueryModifiers

	Projection() Expression
	SetProjection(e Expression)

	SetParam(e ParamExpression, v interface{})
	Params() []ParamMetadata

	SetDistinct(d bool)
	Distinct() bool

	SetUnique(u bool)
	Unique() bool

	Reset()
}

// ParamsBuilder
func VisitWithDefaultParamsBuilder(e Expression) QueryMetadata {
	qm := &BasicQueryMetadata{}
	VisitWithBuilder[QueryMetadata, struct{}](ParamsBuilder{}, qm, e)
	return qm
}

type ParamsBuilder struct{}

func (b ParamsBuilder) Visit(qm QueryMetadata, e Expression) struct{} {
	if sqe, ok := e.(SubQueryExpression); ok {
		md := sqe.Metadata()
		for _, p := range md.Params() {
			qm.SetParam(p.e, p.v)
		}
		for _, gb := range md.GroupBy() {
			b.Visit(qm, gb)
		}
		b.Visit(qm, md.Having())
		for _, j := range md.Joins() {
			b.Visit(qm, j.Target())
			b.Visit(qm, j.Condition())
		}
		b.Visit(qm, md.Projection())
		b.Visit(qm, md.Where())
	}
	if o, ok := e.(Operation); ok {
		for _, arg := range o.Args() {
			b.Visit(qm, arg)
		}
	}
	// TODO - QueryExpressions - This will pull in the SQL logic
	// panic(fmt.Errorf("there is no case for this expression: %+v", e))
	return struct{}{}
}

// ValidatingBuilder
func VisitWithDefaultValidatingBuilder(e Expression) []Expression {
	return VisitWithBuilder[[]Expression, []Expression](ValidatingBuilder{}, make([]Expression, 0, 10), e)
}

type ValidatingBuilder struct{}

func (b ValidatingBuilder) Visit(known []Expression, e Expression) []Expression {
	if o, ok := e.(Operation); ok {
		if o.Operator() == OpAlias {
			known = append(known, o.Arg(1))
		}
		for _, arg := range o.Args() {
			known = append(known, b.Visit(known, arg)...)
		}
	}
	if p, ok := e.(Path); ok {
		var found = false
		for _, k := range known {
			if k == p || k == e {
				found = true
				break
			}
		}
		if !found {
			panic(fmt.Errorf("unknown path '%s' - add the path as a source to the query to be able to use it", p.Root()))
		}
	}
	return known
}

// PathBuilder
func VisitWithDefaultPathBuilder(e Expression) Path {
	return VisitWithBuilder[struct{}, Path](PathBuilder{}, struct{}{}, e)
}

type PathBuilder struct{}

func (b PathBuilder) Visit(ctx struct{}, e Expression) Path {
	if p, ok := e.(Path); ok {
		return p
	}
	if o, ok := e.(Operation); ok {
		for _, arg := range o.Args() {
			if p := b.Visit(ctx, arg); p != nil {
				return p
			}
		}
	}
	// panic(fmt.Errorf("there is no case for this expression: %+v", e))
	return nil
}

// PathsBuilder
func VisitWithDefaultPathsBuilder(e Expression) []Path {
	return VisitWithBuilder[[]Path, []Path](PathsBuilder{}, make([]Path, 0, 10), e)
}

type PathsBuilder struct{}

func (b PathsBuilder) Visit(paths []Path, e Expression) []Path {
	if p, ok := e.(Path); ok {
		return append(paths, p)
	}
	if o, ok := e.(Operation); ok {
		for _, arg := range o.Args() {
			paths = b.Visit(paths, arg)
		}
		return paths
	}
	// panic(fmt.Errorf("there is no case for this expression: %+v", e))
	return paths
}

// ToStringBuilder
func VisitWithDefaultToStringBuilder(e Expression) string {
	return VisitWithBuilder[Templates, string](ToStringBuilder{}, DefaultTemplates(), e)
}

type ToStringBuilder struct{}

func (b ToStringBuilder) Visit(t Templates, e Expression) string {
	if c, ok := e.(ConstantExpression); ok {
		return fmt.Sprintf("%v", c.Interface())
	}
	if o, ok := e.(Operation); ok {
		op := o.Operator()
		// Make sure this is something we _should_ be able to build.
		syntax, ok := t[op]
		if !ok {
			return fmt.Sprintf("unknown operation for operator %s and args %v", op, o.Args())
		}

		value := syntax.Replace(func(idx int) string {
			arg := o.Arg(idx)
			if arg == nil {
				return fmt.Sprintf("unknown argument at index '%d' for syntax '%s'", idx, syntax)
			}
			if argOp, ok := arg.(Operation); ok {
				return "(" + b.Visit(t, argOp) + ")"
			} else {
				return b.Visit(t, arg)
			}
		})
		return value
	}
	if p, ok := e.(Path); ok {
		parent := p.Metadata().Parent()
		elem := p.Metadata().Elem()

		if parent == nil {
			return fmt.Sprintf("%v", elem)
		}
		// Make sure this is a path type we can build
		syntax, ok := t[p.Metadata().PathType()]
		if !ok {
			return fmt.Sprintf("unknown operation for path type %v", p.Metadata().PathType())
		}

		values := []interface{}{parent, elem}
		value := syntax.Replace(func(idx int) string {
			if idx > 2 {
				return ""
			}
			if exp, ok := values[idx].(Expression); ok {
				return b.Visit(t, exp)
			}
			return fmt.Sprintf("%v", values[idx])
		})
		return value
	}
	panic(fmt.Errorf("there is no case for this expression: %+v", e))
}

type SQLBuilderStage int

const (
	SelectStage SQLBuilderStage = iota
	FromStage
	WhereStage
	GroupByStage
	HavingStage
	OrderByStage
	ModifierStage
)

type SQLBuilder struct {
	b             strings.Builder // TODO - Optimize strings!
	dml           bool            // ModifyQuery=true vs Read=false
	includeSchema bool            // includeSchema on statements
	skipParent    bool
	constants     []interface{}
	entity        Path
	constantPaths []Path
	aliases       []Path
	stage         SQLBuilderStage
}

func (b *SQLBuilder) Visit(t SQLTemplates, e Expression) struct{} {
	if p, ok := e.(ParamExpression); ok {
		b.b.WriteRune('?')
		b.constants = append(b.constants, p)
		if len(b.constantPaths) < len(b.constants) {
			b.constantPaths = append(b.constantPaths, nil)
		}
		return struct{}{}
	}
	if op, ok := e.(Operation); ok {
		args := op.Args()
		if len(args) == 2 {
			// NumCast
		}

		// if op.Operator() == OpSet && op.Arg(0) == SubQueryExpression {
		// 	// Union Stuff
		// }

		// Others
		stx, ok := t.FindSyntax(op)
		if !ok {
			panic(fmt.Sprintf("unknown snytax for operation %v", op))
		}

		value := stx.Replace(func(idx int) string {
			if idx >= len(args) {
				return ""
			}
			return fmt.Sprintf("%v", args[idx])
		})
		b.append(value)
	}

	// Operator() Operator
	// Arg(idx int) Expression
	// Args() []Expression

	if p, ok := e.(Path); ok {
		if b.dml {
			relPath, ok := e.(RelationalPath)
			if p == b.entity && ok {
				schema, table := relPath.Schema(), relPath.Table()

				var hasDot bool
				if b.includeSchema && t.ShouldPrintSchema() {
					hasDot = true
					b.appendSchema(t, schema)
					b.appendDot()
				}
				b.appendTable(t, table, hasDot)
				return struct{}{}
			}
			if e == p.Metadata().Parent() && b.skipParent {
				b.appendAsColumnName(t, p, false)
				return struct{}{}
			}
		}

		var hasDot bool
		if parent := p.Metadata().Parent(); parent != nil && (!b.skipParent || b.dml) {
			hasDot = true

			b.Visit(t, parent)
			b.appendDot()
		}
		b.appendAsColumnName(t, p, hasDot)
	}
	return struct{}{}
}

func (b *SQLBuilder) append(s string) {
	b.b.WriteString(s)
}

func (b *SQLBuilder) appendDot() {
	b.b.WriteRune('.')
}

func (b *SQLBuilder) appendSchema(t SQLTemplates, name string) {
	b.append(t.QuoteID(name, false))
}

func (b *SQLBuilder) appendTable(t SQLTemplates, name string, hasDot bool) {
	b.append(t.QuoteID(name, hasDot))
}

func (b *SQLBuilder) appendAsColumnName(t SQLTemplates, p Path, hasDot bool) {
	name := p.Metadata().Name()

	parent := p.Metadata().Parent()
	if ep, ok := parent.(EntityPath); ok {
		name = ep.MetadataForPath(p).Name()
	}
	b.append(t.QuoteID(name, hasDot))
}
