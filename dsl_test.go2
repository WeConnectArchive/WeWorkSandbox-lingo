package lingo

import (
	"encoding/json"
	"fmt"
	"sync/atomic"
	"testing"
)

func printDebug(msg string, v interface{}) {
	countNum := atomic.AddInt64(&counter, 1)
	fmt.Println(msg)
	fmt.Printf("%d => %+v\n", countNum, v)
	bytes, err := json.Marshal(v)
	if err != nil {
		panic(err)
	}
	fmt.Printf("%d => %s\n", countNum, string(bytes))
}

// The playground now uses square brackets for type parameters. Otherwise,
// the syntax of type parameter lists matches the one of regular parameter
// lists except that all type parameters must have a name, and the type
// parameter list cannot be empty. The predeclared identifier "any" may be
// used in the position of a type parameter constraint (and only there);
// it indicates that there are no constraints.

func TestDSL(t *testing.T) {
	var tactor = NewTActorForVariable("asdf")
	printDebug("tactor", tactor)
	printDebug("tactor.type", tactor.Type())
	printDebug("tactor.ActorID", tactor.ActorID)
	printDebug("tactor.ActorID.Type()", tactor.ActorID.Type())
	printDebug("tactor.IsActive", tactor.IsActive)
	printDebug("tactor.IsActive.Type()", tactor.IsActive.Type())
	printDebug("tactor.ActorID.Eq(tactor.ActorID)", tactor.ActorID.Eq(tactor.ActorID))

	tactor.ActorID.Eq(tactor.ActorID)

	// var actor = NewTActorForVariable("myvariablew")
	// fmt.Println(tsv.VisitPath(tmpl, actor.ActorID))

	// gt := actor.ActorID.GT(int16(5))
	// fmt.Println(tsv.VisitPath(tmpl, gt))
}
