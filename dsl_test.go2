package lingo

import (
	"fmt"
	"reflect"
	"sync/atomic"
	"testing"
)

var printDebugCounter uint64

func printDebug(msg string, v interface{}) {
	countNum := atomic.AddUint64(&printDebugCounter, 1)
	fmt.Println(msg)
	fmt.Printf("   %3d => %+v\n\n", countNum, v)
}

func TestPathMetadata_VariableProperty(t *testing.T) {
	type want struct {
		wantType     reflect.Type
		wantPathType PathType
		wantParent   Path
		wantRoot     Path
		wantIsRoot   bool
		wantElem     Expression
		wantName     string
	}
	sp := NewVariable[bool]("bool_simple_path")
	tests := []struct {
		tname    string
		input    Path
		wantData want
	}{
		{
			tname: `NewVariable("varName")`,
			input: NewVariable[string]("varName"),
			wantData: want{
				wantType:     reflect.TypeOf(Variable),
				wantPathType: Variable,
				wantParent:   nil,
				wantRoot:     nil,
				wantIsRoot:   true,
				wantElem:     constantStringExpression("varName"),
				wantName:     "varName",
			},
		},
		{
			tname: `NewProperty("propName", sp)`,
			input: NewProperty[string]("propName", sp),
			wantData: want{
				wantType:     reflect.TypeOf(Property),
				wantPathType: Property,
				wantParent:   sp,
				wantRoot:     sp.LingoPathData().Root(),
				wantIsRoot:   false,
				wantElem:     constantStringExpression("propName"),
				wantName:     "propName",
			},
		},
	}

	for idx, tc := range tests {
		OnNotEqualFatalf(t, idx, tc.tname, "Type", tc.input.Type(), tc.wantData.wantType)
		OnNotEqualFatalf(t, idx, tc.tname, "Parent", tc.input.LingoPathData().Parent(), tc.wantData.wantParent)
		OnNotEqualFatalf(t, idx, tc.tname, "Root", tc.input.LingoPathData().Root(), tc.wantData.wantRoot)
		OnNotEqualFatalf(t, idx, tc.tname, "Value", tc.input.LingoPathData().Value(), tc.wantData.wantElem)
		OnNotEqualFatalf(t, idx, tc.tname, "Name", tc.input.LingoPathData().Name(), tc.wantData.wantName)
	}
}

func OnNotDeepEqualFatalf[T comparable](t *testing.T, idx int, name, sub string, left, right T) {
	if reflect.DeepEqual(left, right) {
		t.Fatalf("error[%d-%s-%s] expected %+v, got: %+v", idx, name, sub, left, right)
	}
}

func OnNotEqualFatalf[T comparable](t *testing.T, idx int, name, sub string, left, right T) {
	if left != right {
		t.Fatalf("error[%d-%s-%s] expected %+v, got: %+v", idx, name, sub, left, right)
	}
}

func TestDSL(t *testing.T) {
	var tactor = NewTActorAs("a")
	printDebug("tactor", tactor)
	printDebug("tactor.ActorID", tactor.ActorID)
	printDebug("tactor.ActorID.EqValue(int16(10))", tactor.ActorID.EqValue(int16(10)))
	var exp = tactor.IsActive.Eq(tactor.IsActive.IsTrue())
	printDebug("tactor.IsActive.Eq(tactor.IsActive.EqValue(true))", exp)
	printDebug(`exp.As("aliasName")`, exp.As("aliasName"))

	var exp2 = tactor.ActorID.Eq(tactor.ActorID.EqValue(10))
	printDebug("tactor.ActorID.Eq(tactor.ActorID.Eq(10))", exp2)
	printDebug(`exp2.As("aliasName")`, exp2.As("aliasName"))

	var exp3 = tactor.ActorID.BetweenValues(int16(10), int16(15))
	printDebug("tactor.ActorID.BetweenValues(10, 15)", exp3)

	var mathExp NumberExpression[int16] = tactor.ActorID
	printDebug("NumberExpression[int16](tactor.ActorID)", mathExp)

	var mathPath NumberPath[int16] = tactor.ActorID
	printDebug("NumberPath[int16](tactor.ActorID)", mathPath)

	var boolExp BooleanExpression = tactor.IsActive
	printDebug("BooleanExpression(tactor.IsActive)", boolExp)

	var boolPath BoolPath = tactor.IsActive
	printDebug("BoolPath(tactor.IsActive)", boolPath)

	var typedBoolPath TypedPath[bool] = tactor.IsActive
	printDebug("TypedPath[bool](tactor.IsActive)", typedBoolPath)

	var strExp StringExpression = tactor.FirstName
	printDebug("StringExpression(tactor.FirstName)", strExp)

	var stringPath StringPath = tactor.FirstName
	printDebug("StringPath(tactor.FirstName)", stringPath)

	var constExp ConstantExpression = NewConstant[string]("constantExpressionHere")
	printDebug("ConstantExpression()", constExp)

	var qm QueryMetadata = &BasicQueryMetadata{}
	qm.AddJoin(InnerJoinType(), strExp)
	qm.AddWhere(exp3)
	printDebug("qm", qm)

	joinTypes := map[JoinType]string{
		DefaultJoinType(): "JOIN",
		InnerJoinType():   "INNER JOIN",
		JoinJoinType():    "JOIN",
		LeftJoinType():    "LEFT JOIN",
		RightJoinType():   "RIGHT JOIN",
		FullJoinType():    "FULL JOIN",
	}

	defTemplates := DefaultTemplates()
	sqlTemplates := SQLTemplates{
		templates: defTemplates,
		joinTypes: joinTypes,
	}

	var tfilm = NewTFilmAs("f")
	printDebug("tfilm", tfilm)

	// TODO: Have to type cast this, I dont think the new Type system does this many levels deep yet?
	firstNameTE := TypedExpression[string](tactor.FirstName)
	var selQuery = SelectColumn(firstNameTE).From(tactor)
	selQuery.LeftJoin(tfilm, tfilm.MainActorID.Eq(tactor.ActorID))
	selQuery.Where(tactor.IsActive.IsTrue())
	selQuery.Where(tactor.FirstName.LocateValue("123").GTValue(10).Or(tactor.FirstName.InValues("abc", "def", "ghi")))
	printDebug("selQuery", selQuery)

	sqlStr, sqlStrValues := selQuery.Build(sqlTemplates)
	printDebug("sqlStr", sqlStr)
	printDebug("sqlStrValues", sqlStrValues)

	var selManyQuery = SelectColumns(tactor.FirstName, tactor.LastName).From(tactor)
	selManyQuery.LeftJoin(tfilm, tfilm.MainActorID.Eq(tactor.ActorID))
	selManyQuery.Where(tactor.FirstName.InValues("abc", "def", "ghi"))
	printDebug("selManyQuery", selManyQuery)

	sqlStr, sqlStrValues = selManyQuery.Build(sqlTemplates)
	printDebug("sqlStr", sqlStr)
	printDebug("sqlStrValues", sqlStrValues)

	// var ic = NewSQLInsertClause()
	// ic.Set(tactor.IsActive, true)
	// printDebug("ic", ic)

	// var uc = NewSQLUpdateClause()
	// uc.Where(exp)
	// printDebug("uc", uc)
}
