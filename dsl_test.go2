package lingo

import (
	"fmt"
	"reflect"
	"sync/atomic"
	"testing"
)

func printDebug(msg string, v interface{}) {
	countNum := atomic.AddInt64(&counter, 1)
	fmt.Println(msg)
	fmt.Printf("   %3d => %+v\n\n", countNum, v)
}

func TestPathMetadata_VariableProperty(t *testing.T) {
	type want struct {
		wantType     reflect.Type
		wantPathType PathType
		wantParent   Path
		wantRoot     Path
		wantIsRoot   bool
		wantElem     Expression
		wantName     string
	}
	sp := NewSimplePath[bool](false, NewPathMetadataForVariable("bool_simple_path"))
	tests := []struct {
		tname    string
		input    PathMetadata
		wantData want
	}{
		{
			tname: `NewPathMetadataForVariable("varName")`,
			input: NewPathMetadataForVariable("varName"),
			wantData: want{
				wantType:     reflect.TypeOf(Variable),
				wantPathType: Variable,
				wantParent:   nil,
				wantRoot:     nil,
				wantIsRoot:   true,
				wantElem:     constantStringExpression("varName"),
				wantName:     "varName",
			},
		},
		{
			tname: `NewPathMetadataForProperty("propName", sp)`,
			input: NewPathMetadataForProperty("propName", sp),
			wantData: want{
				wantType:     reflect.TypeOf(Property),
				wantPathType: Property,
				wantParent:   sp,
				wantRoot:     sp.Root(),
				wantIsRoot:   false,
				wantElem:     constantStringExpression("propName"),
				wantName:     "propName",
			},
		},
	}

	for idx, tc := range tests {
		OnNotEqualFatalf(t, idx, tc.tname, "Type", tc.input.Type(), tc.wantData.wantType)
		OnNotEqualFatalf(t, idx, tc.tname, "PathType", tc.input.PathType(), tc.wantData.wantPathType)
		OnNotEqualFatalf(t, idx, tc.tname, "Parent", tc.input.Parent(), tc.wantData.wantParent)
		OnNotEqualFatalf(t, idx, tc.tname, "Root", tc.input.Root(), tc.wantData.wantRoot)
		OnNotEqualFatalf(t, idx, tc.tname, "IsRoot", tc.input.IsRoot(), tc.wantData.wantIsRoot)
		OnNotEqualFatalf(t, idx, tc.tname, "Elem", tc.input.Elem(), tc.wantData.wantElem)
		OnNotEqualFatalf(t, idx, tc.tname, "Name", tc.input.Name(), tc.wantData.wantName)
	}
}

func OnNotDeepEqualFatalf[T comparable](t *testing.T, idx int, name, sub string, left, right T) {
	if reflect.DeepEqual(left, right) {
		t.Fatalf("error[%d-%s-%s] expected %+v, got: %+v", idx, name, sub, left, right)
	}
}

func OnNotEqualFatalf[T comparable](t *testing.T, idx int, name, sub string, left, right T) {
	if left != right {
		t.Fatalf("error[%d-%s-%s] expected %+v, got: %+v", idx, name, sub, left, right)
	}
}

func TestDSL(t *testing.T) {
	var tactor = NewTActorForVariable("a")
	printDebug("tactor", tactor)
	printDebug("tactor.ActorID", tactor.ActorID)
	printDebug("tactor.ActorID.EqValue(int16(10))", tactor.ActorID.EqValue(int16(10)))
	var exp = tactor.IsActive.Eq(tactor.IsActive.IsTrue())
	printDebug("tactor.IsActive.Eq(tactor.IsActive.EqValue(true))", exp)
	printDebug(`exp.As("aliasName")`, exp.As("aliasName"))

	var exp2 = tactor.ActorID.Eq(tactor.ActorID.EqValue(10))
	printDebug("tactor.ActorID.Eq(tactor.ActorID.Eq(10))", exp2)
	printDebug(`exp2.As("aliasName")`, exp2.As("aliasName"))

	var exp3 = tactor.ActorID.BetweenValues(int16(10), int16(15))
	printDebug("tactor.ActorID.BetweenValues(10, 15)", exp3)

	var mathExp NumberExpression[int16] = tactor.ActorID
	printDebug("NumberExpression[int16](tactor.ActorID)", mathExp)

	var mathPath NumberPath[int16] = tactor.ActorID
	printDebug("NumberPath[int16](tactor.ActorID)", mathPath)

	var boolExp BooleanExpression = tactor.IsActive
	printDebug("BooleanExpression(tactor.IsActive)", boolExp)

	var boolPath BoolPath = tactor.IsActive
	printDebug("BoolPath(tactor.IsActive)", boolPath)

	var typedBoolPath TypedPath[bool] = tactor.IsActive
	printDebug("TypedPath[bool](tactor.IsActive)", typedBoolPath)

	var strExp StringExpression = tactor.FirstName
	printDebug("StringExpression(tactor.FirstName)", strExp)

	var stringPath StringPath = tactor.FirstName
	printDebug("StringPath(tactor.FirstName)", stringPath)

	var constExp ConstantExpression = NewSimpleConstant[string]("constantExpressionHere")
	printDebug("ConstantExpression()", constExp)

	var qm QueryMetadata = &BasicQueryMetadata{}
	qm.AddJoin(InnerJoinType(), strExp)
	qm.AddWhere(exp3)
	printDebug("qm", qm)

	var ic = NewSQLInsertClause()
	ic.Set(tactor.IsActive, true)
	printDebug("ic", ic)

	var uc = NewSQLUpdateClause()
	uc.Where(exp)
	printDebug("uc", uc)

	// TODO: Have to type cast this, I dont think the new Type system does this many levels deep yet?
	firstNameTE := TypedExpression[string](tactor.FirstName)
	var selQuery = SelectColumn(firstNameTE).From(tactor)
	selQuery.Where(tactor.FirstName.LocateValue("123").GTValue(10))
	selQuery.Where(tactor.FirstName.InValues("abc", "def", "ghi"))
	printDebug("selQuery", selQuery)

	joinTypes := map[JoinType]string{
		DefaultJoinType(): DefaultJoinType().String(),
		InnerJoinType():   InnerJoinType().String(),
		JoinJoinType():    JoinJoinType().String(),
		LeftJoinType():    LeftJoinType().String(),
		RightJoinType():   RightJoinType().String(),
		FullJoinType():    FullJoinType().String(),
	}

	defTemplates := DefaultTemplates()
	sqlTemplates := SQLTemplates{
		templates: defTemplates,
		joinTypes: joinTypes,
	}

	sqlStr, _ := selQuery.Build(sqlTemplates)
	printDebug("sqlStr", sqlStr)
}
