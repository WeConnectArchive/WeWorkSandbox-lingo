package lingo

import (
	"fmt"
	"reflect"
)

type PathType int

func (p PathType) Type() reflect.Type {
	return reflect.TypeOf(p)
}

const (
	Unknown PathType = iota

	ArrayValue
	ArrayValueConstant
	CollectionAny
	Delegate
	ListValue
	ListValueConstant
	MapValue
	MapValueConstant
	Property
	Variable
)

func NewPathMetadataForVariable(varName string) PathMetadata { return NewPathMetadata(Variable, varName, nil) }
func NewPathMetadataForProperty(propName string, parent Path) PathMetadata { return NewPathMetadata(Property, propName, parent)}
func NewPathMetadata(pt PathType, element interface{}, parent Path) PathMetadata {
	var root Path
	if parent != nil {
		root = parent.Root()
	}
	return PathMetadata{
		pathType: pt,
		root: root,
		parent: parent,
		element: element,
	}
}
type PathMetadata struct {
	pathType PathType
	root Path
	parent Path
	element interface{}
}
func (pm PathMetadata) Type() reflect.Type { return reflect.TypeOf(pm.pathType) }
func (pm PathMetadata) IsZero() bool {
	return pm == PathMetadata{}
}
func (pm PathMetadata) PathType() PathType { return pm.pathType }
func (pm PathMetadata) Parent() Path { return pm.parent }
func (pm PathMetadata) Root() Path { return pm.root }
func (pm PathMetadata) IsRoot() bool {
	return pm.Parent() == nil || (pm.PathType() == Delegate && pm.Parent().Metadata().IsRoot())
}
func (pm PathMetadata) Elem() interface{} { return pm.element }
func (pm PathMetadata) Name() string {
	switch pm.pathType {
	case Variable, Property:
		return pm.Elem().(string)
	}
	panic(fmt.Sprintf("name property not available for path type %d, must be accessed with Element()", pm.pathType))
}

// ================================================
// PATH
type Path interface {
	Expression
	Metadata() PathMetadata
	Root() Path
}
type TypedPath[T any] interface {
	TypedExpression[T]
	Path
}

// -------------------------------------
// NewSimplePath
func NewSimplePathForProperty[T any](value T, propName string, parent Path) SimplePath[T] {
	return NewSimplePath[T](value, NewPathMetadataForProperty(propName, parent))
}
func NewSimplePathForVariable[T any](value T, variableName string) SimplePath[T] {
	return NewSimplePath[T](value, NewPathMetadataForVariable(variableName))
}
func NewSimplePath[T any](value T, pm PathMetadata) SimplePath[T] {
	return SimplePath[T]{
		value: value,
		pm: pm,
	}
}
type SimplePath[T any] struct {
	value T
	pm PathMetadata
}
func (p SimplePath[T]) Type() reflect.Type { return p.pm.Type() }
func (p SimplePath[T]) String() string { return VisitWithDefaultToStringBuilder(p) }
func (p SimplePath[T]) Metadata() PathMetadata { return p.pm }
func (p SimplePath[T]) Root() Path { return p.pm.Root() }

// -------------------------------------
// NewBoolPath
func NewBoolPath(p SimplePath[bool]) BoolPath {
	return BoolPath{
		mixin: p,
	}
}
type BoolPath struct {
	mixin SimplePath[bool] // & BooleanExpression
}
func (p BoolPath) Type() reflect.Type { return p.mixin.Type() }
func (p BoolPath) String() string { return VisitWithDefaultToStringBuilder(p) }
func (p BoolPath) Metadata() PathMetadata { return p.mixin.Metadata() }
func (p BoolPath) Root() Path { return p.mixin.Root() }

func (p BoolPath) And(e PredicateExpression) BooleanExpression {
	return NewOpAnd(p, e)
}
func (p BoolPath) Not() BooleanExpression {
	return NewOpNot(p)
}
func (p BoolPath) Or(e PredicateExpression) BooleanExpression {
	return NewOpOr(p, e)
}

func (p BoolPath) IsTrue() BooleanExpression {
	return p.EqValue(true)
}
func (p BoolPath) IsFalse() BooleanExpression {
	return p.EqValue(false)
}

func (p BoolPath) EqValue(v bool) BooleanExpression {
	return p.Eq(NewSimpleConstant[bool](v))
}
func (p BoolPath) Eq(v TypedExpression[bool]) BooleanExpression {
	return NewOpEqual(p, v)
}

// -------------------------------------
// NewNumberPath
func NewNumberPath[T numeric](p SimplePath[T]) NumberPath[T] {
	return NumberPath[T]{
		mixin: p,
	}
}
type NumberPath[T numeric] struct {
	NumberExpression[T]
	mixin SimplePath[T]
}
func (p NumberPath[T]) Type() reflect.Type { return p.mixin.Type() }
func (p NumberPath[T]) String() string { return VisitWithDefaultToStringBuilder(p) }
func (p NumberPath[T]) Metadata() PathMetadata { return p.mixin.Metadata() }
func (p NumberPath[T]) Root() Path { return p.mixin.Root() }

// -- LiteralExpression
func (p NumberPath[T]) StringValue() StringExpression {
	return NewStringOperation(OpStringCast, p)
}

// -- ComparableExpression
func (p NumberPath[T]) Asc() Order[T] {
	return nil
}
func (p NumberPath[T]) BetweenValues(l, r T) BooleanExpression {
	return p.Between(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (p NumberPath[T]) Between(l, r TypedExpression[T]) BooleanExpression {
	return NewOpBetween(p, l, r)
}
func (p NumberPath[T]) NotBetweenValues(l, r T) BooleanExpression {
	return p.NotBetween(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (p NumberPath[T]) NotBetween(l, r TypedExpression[T]) BooleanExpression {
	return NewOpNotBetween(p, l, r)
}
func (p NumberPath[T]) GTValue(v T) BooleanExpression {
	return p.GT(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) GT(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThan(p, e)
}
func (p NumberPath[T]) GTOrEqValue(v T) BooleanExpression {
	return p.GTOrEq(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) GTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThanOrEqual(p, e)
}
func (p NumberPath[T]) LTValue(v T) BooleanExpression {
	return p.LT(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) LT(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThan(p, e)
}
func (p NumberPath[T]) LTOrEqValue(v T) BooleanExpression {
	return p.LTOrEq(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) LTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThanOrEqual(p, e)
}

// -- NumberExpression
func (p NumberPath[T]) AsPath(a TypedPath[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpAlias, p, a)
}
func (p NumberPath[T]) As(alias string) NumberExpression[T] {
	return p.AsPath(NewSimplePathForVariable[T](T(0), alias))
}

func (p NumberPath[T]) EqValue(v T) BooleanExpression {
	return p.Eq(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) Eq(v TypedExpression[T]) BooleanExpression {
	return NewOpEqual(p, v)
}

func (p NumberPath[T]) Max(l, r TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpMax, l, r)
}
func (p NumberPath[T]) Min(l, r TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpMin, l, r)
}



// -------------------------------------
// NewStringPath
func NewStringPath(p SimplePath[string]) StringPath {
	return StringPath{
		mixin: p,
	}
}
type StringPath struct {
	StringExpression
	mixin SimplePath[string]
}
