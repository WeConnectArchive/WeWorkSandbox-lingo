package lingo

import (
	"fmt"
	"reflect"
	"regexp"
)

type PathType int

func (p PathType) Type() reflect.Type {
	return reflect.TypeOf(p)
}

const (
	Unknown PathType = iota

	ArrayValue
	ArrayValueConstant
	CollectionAny
	Delegate
	ListValue
	ListValueConstant
	MapValue
	MapValueConstant
	Property
	Variable
)

func NewPathMetadataForVariable(varName string) PathMetadata {
	return NewPathMetadata(Variable, constantStringExpression(varName), nil)
}
func NewPathMetadataForProperty(propName string, parent Path) PathMetadata {
	return NewPathMetadata(Property, constantStringExpression(propName), parent)
}
func NewPathMetadata(pt PathType, element Expression, parent Path) PathMetadata {
	var root Path
	if parent != nil {
		root = parent.Root()
	}
	return PathMetadata{
		pathType: pt,
		root:     root,
		parent:   parent,
		element:  element,
	}
}

type PathMetadata struct {
	pathType PathType
	root     Path
	parent   Path
	element  Expression
}

func (pm PathMetadata) Type() reflect.Type { return reflect.TypeOf(pm.pathType) }
func (pm PathMetadata) IsZero() bool {
	return pm == PathMetadata{}
}
func (pm PathMetadata) PathType() PathType { return pm.pathType }
func (pm PathMetadata) Parent() Path       { return pm.parent }
func (pm PathMetadata) Root() Path         { return pm.root }
func (pm PathMetadata) IsRoot() bool {
	return pm.Parent() == nil || (pm.PathType() == Delegate && pm.Parent().Metadata().IsRoot())
}
func (pm PathMetadata) Elem() Expression { return pm.element }
func (pm PathMetadata) Name() string {
	switch pm.pathType {
	case Variable, Property:
		return pm.Elem().String()
	}
	panic(fmt.Sprintf("name property not available for path type %d, must be accessed with Element()", pm.pathType))
}

// ================================================
// PATH
type Path interface {
	Expression
	Metadata() PathMetadata
	Root() Path
}

type TypedPath[T any] interface {
	TypedExpression[T]
	Path
}

// -------------------------------------
// NewSimplePath
func NewSimplePathForProperty[T any](propName string, parent Path) SimplePath[T] {
	return NewSimplePath[T](NewPathMetadataForProperty(propName, parent))
}
func NewSimplePathForVariable[T any](variableName string) SimplePath[T] {
	return NewSimplePath[T](NewPathMetadataForVariable(variableName))
}
func NewSimplePath[T any](pm PathMetadata) SimplePath[T] {
	return SimplePath[T]{
		pm:    pm,
	}
}

type SimplePath[T any] struct {
	pm    PathMetadata
}

func (p SimplePath[T]) Type() reflect.Type     { return p.pm.Type() }
func (p SimplePath[T]) String() string         { return VisitWithDefaultToStringBuilder(p) }
func (p SimplePath[T]) Metadata() PathMetadata { return p.pm }
func (p SimplePath[T]) Root() Path             { return p.pm.Root() }

// -------------------------------------
// NewBoolPath
func NewBoolPath(p SimplePath[bool]) BoolPath {
	return BoolPath{
		mixin: p,
	}
}

type BoolPath struct {
	mixin SimplePath[bool] // & BooleanExpression
}

// -- Expression
func (p BoolPath) Type() reflect.Type { return p.mixin.Type() }
func (p BoolPath) String() string     { return VisitWithDefaultToStringBuilder(p) }

// -- Path
func (p BoolPath) Metadata() PathMetadata { return p.mixin.Metadata() }
func (p BoolPath) Root() Path             { return p.mixin.Root() }

// -- BooleanExpression
func (o BoolPath) As(alias string) BooleanExpression {
	return o.AsPath(NewSimplePathForVariable[bool](alias))
}
func (o BoolPath) AsPath(p TypedPath[bool]) BooleanExpression {
	return NewOpAlias(o, p)
}
func (p BoolPath) And(e PredicateExpression) BooleanExpression {
	return NewOpAnd(p, e)
}
func (p BoolPath) Not() BooleanExpression {
	return NewOpNot(p)
}
func (p BoolPath) Or(e PredicateExpression) BooleanExpression {
	return NewOpOr(p, e)
}
func (p BoolPath) IsTrue() BooleanExpression {
	return p.EqValue(true)
}
func (p BoolPath) IsFalse() BooleanExpression {
	return p.EqValue(false)
}
func (p BoolPath) EqValue(v bool) BooleanExpression {
	return p.Eq(NewConstant[bool](v))
}
func (p BoolPath) Eq(v TypedExpression[bool]) BooleanExpression {
	return NewOpEqual(p, v)
}
func (p BoolPath) NotEqValue(v bool) BooleanExpression {
	return p.NotEq(NewConstant[bool](v))
}
func (p BoolPath) NotEq(v TypedExpression[bool]) BooleanExpression {
	return p.Eq(v).Not()
}

// -------------------------------------
// NewNumberPath
func NewNumberPath[T numeric](p SimplePath[T]) NumberPath[T] {
	return NumberPath[T]{
		mixin: p,
	}
}

// NumberPath is a basic NumberExpression of numberic type T
type NumberPath[T numeric] struct {
	mixin SimplePath[T]
}

// -- Expression
func (p NumberPath[T]) Type() reflect.Type { return p.mixin.Type() }
func (p NumberPath[T]) String() string     { return VisitWithDefaultToStringBuilder(p) }

// -- Path
func (p NumberPath[T]) Metadata() PathMetadata { return p.mixin.Metadata() }
func (p NumberPath[T]) Root() Path             { return p.mixin.Root() }

// -- LiteralExpression
func (p NumberPath[T]) StringValue() StringExpression {
	return NewStringOperation(OpStringCast, p)
}

// -- AnyComparableExpression
func (p NumberPath[T]) Asc() Order {
	return NewOrderByDefaultNull[T](OrderAsc, p)
}
func (p NumberPath[T]) Desc() Order {
	return NewOrderByDefaultNull[T](OrderDesc, p)
}

// -- ComparableExpression
func (p NumberPath[T]) BetweenValues(l, r T) BooleanExpression {
	return p.Between(NewConstant[T](l), NewConstant[T](r))
}
func (p NumberPath[T]) Between(l, r TypedExpression[T]) BooleanExpression {
	return NewOpBetween(p, l, r)
}
func (p NumberPath[T]) NotBetweenValues(l, r T) BooleanExpression {
	return p.NotBetween(NewConstant[T](l), NewConstant[T](r))
}
func (p NumberPath[T]) NotBetween(l, r TypedExpression[T]) BooleanExpression {
	return NewOpNotBetween(p, l, r)
}
func (p NumberPath[T]) GTValue(v T) BooleanExpression {
	return p.GT(NewConstant[T](v))
}
func (p NumberPath[T]) GT(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThan(p, e)
}
func (p NumberPath[T]) GTOrEqValue(v T) BooleanExpression {
	return p.GTOrEq(NewConstant[T](v))
}
func (p NumberPath[T]) GTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThanOrEqual(p, e)
}
func (p NumberPath[T]) LTValue(v T) BooleanExpression {
	return p.LT(NewConstant[T](v))
}
func (p NumberPath[T]) LT(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThan(p, e)
}
func (p NumberPath[T]) LTOrEqValue(v T) BooleanExpression {
	return p.LTOrEq(NewConstant[T](v))
}
func (p NumberPath[T]) LTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThanOrEqual(p, e)
}

// -- NumberExpression
func (o NumberPath[T]) Abs() NumberExpression[T] {
	return NewNumberOperation[T](OpAbs, o)
}
func (o NumberPath[T]) AddValue(v T) NumberExpression[T] {
	return o.Add(NewConstant[T](v))
}
func (o NumberPath[T]) Add(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpAddition, o, v)
}
func (o NumberPath[T]) AsPath(p TypedPath[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpAlias, o, p)
}
func (o NumberPath[T]) As(alias string) NumberExpression[T] {
	return o.AsPath(NewSimplePathForVariable[T](alias))
}
func (o NumberPath[T]) Ceil() NumberExpression[T] {
	return NewNumberOperation[T](OpCeiling, o)
}
func (o NumberPath[T]) DivideValue(v T) NumberExpression[T] {
	return o.Divide(NewConstant[T](v))
}
func (o NumberPath[T]) Divide(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpDivision, o, v)
}
func (o NumberPath[T]) EqValue(v T) BooleanExpression {
	return o.Eq(NewConstant[T](v))
}
func (o NumberPath[T]) Eq(v TypedExpression[T]) BooleanExpression {
	return NewOpEqual(o, v)
}
func (o NumberPath[T]) Floor() NumberExpression[T] {
	return NewNumberOperation[T](OpFloor, o)
}
func (o NumberPath[T]) ModValue(v T) NumberExpression[T] {
	return o.Mod(NewConstant[T](v))
}
func (o NumberPath[T]) Mod(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpModulo, o, v)
}
func (o NumberPath[T]) MultiplyValue(v T) NumberExpression[T] {
	return o.Multiply(NewConstant[T](v))
}
func (o NumberPath[T]) Multiply(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpMultiplication, o, v)
}
func (o NumberPath[T]) Negate() NumberExpression[T] {
	return NewNumberOperation[T](OpNegate, o)
}
func (o NumberPath[T]) Round() NumberExpression[T] {
	return NewNumberOperation[T](OpRound, o)
}
func (o NumberPath[T]) Sqrt() NumberExpression[T] {
	return NewNumberOperation[T](OpSquareRoot, o)
}
func (o NumberPath[T]) SubtractValue(v T) NumberExpression[T] {
	return o.Subtract(NewConstant[T](v))
}
func (o NumberPath[T]) Subtract(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpSubtraction, o, v)
}
func (o NumberPath[T]) InValues(v ...T) NumberExpression[T] {
	return o.In(NewConstant[[]T](v))
}
func (o NumberPath[T]) In(v ...TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpIn, o, NewSet[T](v...))
}
func (o NumberPath[T]) NotInValues(v ...T) NumberExpression[T] {
	return o.NotIn(NewConstant[[]T](v))
}
func (o NumberPath[T]) NotIn(v ...TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpNotIn, o, NewSet[T](v...))
}

// -------------------------------------
// NewStringPath is a basic StringExpression path
func NewStringPath(p SimplePath[string]) StringPath {
	return StringPath{
		mixin: p,
	}
}

type StringPath struct {
	mixin SimplePath[string]
}

// -- Expression
func (o StringPath) Type() reflect.Type { return o.mixin.Type() }
func (o StringPath) String() string {
	return o.mixin.String()
}

// -- Path
func (o StringPath) Metadata() PathMetadata {
	return o.mixin.Metadata()
}
func (o StringPath) Root() Path {
	return o.mixin.Root()
}

// -- AnyComparableExpression
func (o StringPath) Asc() Order {
	return NewOrderByDefaultNull[string](OrderAsc, o)
}
func (o StringPath) Desc() Order {
	return NewOrderByDefaultNull[string](OrderDesc, o)
}

// -- ComparableExpression
func (o StringPath) BetweenValues(l, r string) BooleanExpression {
	return o.Between(NewConstant[string](l), NewConstant[string](r))
}
func (o StringPath) Between(l, r TypedExpression[string]) BooleanExpression {
	return NewOpBetween(o, l, r)
}
func (o StringPath) NotBetweenValues(l, r string) BooleanExpression {
	return o.NotBetween(NewConstant[string](l), NewConstant[string](r))
}
func (o StringPath) NotBetween(l, r TypedExpression[string]) BooleanExpression {
	return NewOpNotBetween(o, l, r)
}
func (o StringPath) GTValue(v string) BooleanExpression {
	return o.GT(NewConstant[string](v))
}
func (o StringPath) GT(v TypedExpression[string]) BooleanExpression {
	return NewOpGreaterThan(o, v)
}
func (o StringPath) GTOrEqValue(v string) BooleanExpression {
	return o.GTOrEq(NewConstant[string](v))
}
func (o StringPath) GTOrEq(v TypedExpression[string]) BooleanExpression {
	return NewOpGreaterThanOrEqual(o, v)
}
func (o StringPath) LTValue(v string) BooleanExpression {
	return o.LT(NewConstant[string](v))
}
func (o StringPath) LT(v TypedExpression[string]) BooleanExpression {
	return NewOpLessThan(o, v)
}
func (o StringPath) LTOrEqValue(v string) BooleanExpression {
	return o.LTOrEq(NewConstant[string](v))
}
func (o StringPath) LTOrEq(v TypedExpression[string]) BooleanExpression {
	return NewOpLessThanOrEqual(o, v)
}

// -- LiteralExpression
func (o StringPath) StringValue() StringExpression {
	return o
}

// -- StringExpression
func (o StringPath) As(alias TypedPath[string]) StringExpression {
	return NewStringOperation(OpAlias, o, alias)
}
func (o StringPath) Alias(alias string) StringExpression {
	return o.As(NewSimplePathForVariable[string](alias))
}
func (o StringPath) AppendValue(v string) StringExpression {
	return o.Append(NewConstant[string](v))
}
func (o StringPath) Append(v TypedExpression[string]) StringExpression {
	return NewStringOperation(OpStringConcat, o, v)
}
func (o StringPath) CharAtValue(idx int) TypedExpression[rune] {
	return o.CharAt(NewConstant[int](idx))
}
func (o StringPath) CharAt(idx TypedExpression[int]) TypedExpression[rune] {
	return NewComparableOperation[rune](OpCharAt, o, idx)
}
func (o StringPath) ConcatValue(v string) StringExpression {
	return o.AppendValue(v)
}
func (o StringPath) Concat(v TypedExpression[string]) StringExpression {
	return o.Append(v)
}
func (o StringPath) ContainsValue(v string) BooleanExpression {
	return o.Contains(NewConstant[string](v))
}
func (o StringPath) Contains(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringContains, o, v)
}
func (o StringPath) ContainsFoldValue(v string) BooleanExpression {
	return o.ContainsFold(NewConstant[string](v))
}
func (o StringPath) ContainsFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringContainsFold, o, v)
}
func (o StringPath) EqualsFoldValue(v string) BooleanExpression {
	return o.EqualsFold(NewConstant[string](v))
}
func (o StringPath) EqualsFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpEqualsFold, o, v)
}
func (o StringPath) HasPrefixValue(v string) BooleanExpression {
	return o.HasPrefix(NewConstant[string](v))
}
func (o StringPath) HasPrefix(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasPrefix, o, v)
}
func (o StringPath) HasPrefixFoldValue(v string) BooleanExpression {
	return o.HasPrefixFold(NewConstant[string](v))
}
func (o StringPath) HasPrefixFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasPrefixFold, o, v)
}
func (o StringPath) HasSuffixValue(v string) BooleanExpression {
	return o.HasSuffix(NewConstant[string](v))
}
func (o StringPath) HasSuffix(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasSuffix, o, v)
}
func (o StringPath) HasSuffixFoldValue(v string) BooleanExpression {
	return o.HasSuffixFold(NewConstant[string](v))
}
func (o StringPath) HasSuffixFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasSuffixFold, o, v)
}
func (o StringPath) InValues(v ...string) BooleanExpression {
	return NewBooleanOperation(OpIn, o, NewConstant[[]string](v))
}
func (o StringPath) In(v ...TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpIn, o, NewSet(v...))
}
func (o StringPath) IndexOfValue(v string) NumberExpression[int] {
	return o.IndexOf(NewConstant[string](v))
}
func (o StringPath) IndexOf(v TypedExpression[string]) NumberExpression[int] {
	return NewNumberOperation[int](OpIndexOf, o, v)
}
func (o StringPath) IndexOfNValue(v string, n int) NumberExpression[int] {
	return o.IndexOfN(NewConstant[string](v), n)
}
func (o StringPath) IndexOfN(v TypedExpression[string], n int) NumberExpression[int] {
	return NewNumberOperation[int](OpIndexOfN, o, v, NewConstant[int](n))
}
func (o StringPath) IsEmpty() BooleanExpression {
	return NewBooleanOperation(OpStringIsEmpty, o)
}
func (o StringPath) IsNotEmpty() BooleanExpression {
	return o.IsEmpty().Not()
}
func (o StringPath) Len() NumberExpression[int] {
	return NewNumberOperation[int](OpStringLength, o)
}
func (o StringPath) LikeValue(v string) BooleanExpression {
	return o.Like(NewConstant[string](v))
}
func (o StringPath) Like(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringLike, o, v)
}
func (o StringPath) LikeFoldValue(v string) BooleanExpression {
	return o.LikeFold(NewConstant[string](v))
}
func (o StringPath) LikeFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringLikeFold, o, v)
}
func (o StringPath) LikeEscapeValue(v string, escape rune) BooleanExpression {
	return o.LikeEscape(NewConstant[string](v), escape)
}
func (o StringPath) LikeEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return NewBooleanOperation(OpStringLikeEscape, o, v, NewConstant[rune](escape))
}
func (o StringPath) LikeFoldEscapeValue(v string, escape rune) BooleanExpression {
	return o.LikeFoldEscape(NewConstant[string](v), escape)
}
func (o StringPath) LikeFoldEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return NewBooleanOperation(OpStringLikeFoldEscape, o, v, NewConstant[rune](escape))
}
func (o StringPath) LocateValue(v string) NumberExpression[int] {
	return o.Locate(NewConstant[string](v))
}
func (o StringPath) Locate(v TypedExpression[string]) NumberExpression[int] {
	return NewNumberOperation[int](OpStringLocate, o, v)
}
func (o StringPath) LocateFromValues(v string, start int) NumberExpression[int] {
	return o.LocateFromValue(NewConstant[string](v), start)
}
func (o StringPath) LocateFromValue(v TypedExpression[string], start int) NumberExpression[int] {
	return o.LocateFrom(v, NewConstant[int](start))
}
func (o StringPath) LocateFrom(v TypedExpression[string], start TypedExpression[int]) NumberExpression[int] {
	return NewNumberOperation[int](OpStringLocate2, o, v)
}
func (o StringPath) Lower() StringExpression {
	return NewStringOperation(OpStringLower, o)
}
func (o StringPath) MatchesValue(regex regexp.Regexp) BooleanExpression {
	return o.Matches(NewConstant[string](regex.String()))
}
func (o StringPath) Matches(regex TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringMatches, o, regex)
}
func (o StringPath) NotEqFoldValue(v string) BooleanExpression {
	return o.NotEqFold(NewConstant[string](v))
}
func (o StringPath) NotEqFold(v TypedExpression[string]) BooleanExpression {
	return o.EqualsFold(v).Not()
}

func (o StringPath) NotLikeValue(v string) BooleanExpression {
	return o.NotLike(NewConstant[string](v))
}
func (o StringPath) NotLike(v TypedExpression[string]) BooleanExpression {
	return o.Like(v).Not()
}
func (o StringPath) NotLikeFoldValue(v string) BooleanExpression {
	return o.NotLikeFold(NewConstant[string](v))
}
func (o StringPath) NotLikeFold(v TypedExpression[string]) BooleanExpression {
	return o.LikeFold(v).Not()
}
func (o StringPath) NotLikeEscapeValue(v string, escape rune) BooleanExpression {
	return o.NotLikeEscape(NewConstant[string](v), escape)
}
func (o StringPath) NotLikeEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return o.LikeEscape(v, escape).Not()
}
func (o StringPath) NotLikeFoldEscapeValue(v string, escape rune) BooleanExpression {
	return o.NotLikeFoldEscape(NewConstant[string](v), escape)
}
func (o StringPath) NotLikeFoldEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return o.LikeFoldEscape(v, escape).Not()
}
func (o StringPath) PrependValue(v string) StringExpression {
	return o.Prepend(NewConstant[string](v))
}
func (o StringPath) Prepend(v TypedExpression[string]) StringExpression {
	return NewStringOperation(OpStringConcat, o, v)
}
func (o StringPath) SubstringStartValue(begin int) StringExpression {
	return o.SubstringStart(NewConstant[int](begin))
}
func (o StringPath) SubstringStart(begin TypedExpression[int]) StringExpression {
	return NewStringOperation(OpStringSubstring, o, begin)
}
func (o StringPath) SubstringStartValueEnd(begin int, end TypedExpression[int]) StringExpression {
	return o.SubstringStartEnd(NewConstant[int](begin), end)
}
func (o StringPath) SubstringStartEndValue(begin TypedExpression[int], end int) StringExpression {
	return o.SubstringStartEnd(begin, NewConstant[int](end))
}
func (o StringPath) SubstringStartAndEndValue(begin, end int) StringExpression {
	return o.SubstringStartEnd(NewConstant[int](begin), NewConstant[int](end))
}
func (o StringPath) SubstringStartEnd(begin, end TypedExpression[int]) StringExpression {
	return NewStringOperation(OpStringSubstring2, o, begin, end)
}
func (o StringPath) Trim() StringExpression {
	return NewStringOperation(OpStringTrim, o)
}
func (o StringPath) Upper() StringExpression {
	return NewStringOperation(OpStringToUpper, o)
}

type TableInfo interface {
	Schema() string
	Table() string
	// Columns() []Path
	// PrimaryKey() PrimaryKey
	// ForeignKeys() []ForeignKey
	// InverseForeignKeys() []ForeignKey
	// Metadata(column Path) ColumnMetadata
}

// -------------------------------------
// NewTablePath is a basic Table path
func NewTablePath(md PathMetadata, schema, table string) TablePath {
	return TablePath{
		md: md,
		schema: schema,
		table: table,
	}
}

type TablePath struct {
	md     PathMetadata
	schema string
	table  string
}

// -- Expression
func (o TablePath) Type() reflect.Type { return reflect.TypeOf(o) }
func (o TablePath) String() string {
	return VisitWithDefaultToStringBuilder(o)
}
// -- Path
func (o TablePath) Metadata() PathMetadata {
	return o.md
}
func (o TablePath) Root() Path {
	return o.md.Root()
}
// -- TableInfo
func (o TablePath) Schema() string {
	return o.schema
}
func (o TablePath) Table() string {
	return o.table
}
