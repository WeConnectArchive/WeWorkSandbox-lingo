package lingo

import (
	"fmt"
	"regexp"
	"reflect"
)

type PathType int

func (p PathType) Type() reflect.Type {
	return reflect.TypeOf(p)
}

const (
	Unknown PathType = iota

	ArrayValue
	ArrayValueConstant
	CollectionAny
	Delegate
	ListValue
	ListValueConstant
	MapValue
	MapValueConstant
	Property
	Variable
)

func NewPathMetadataForVariable(varName string) PathMetadata {
	return NewPathMetadata(Variable, varName, nil)
}
func NewPathMetadataForProperty(propName string, parent Path) PathMetadata {
	return NewPathMetadata(Property, propName, parent)
}
func NewPathMetadata(pt PathType, element interface{}, parent Path) PathMetadata {
	var root Path
	if parent != nil {
		root = parent.Root()
	}
	return PathMetadata{
		pathType: pt,
		root:     root,
		parent:   parent,
		element:  element,
	}
}

type PathMetadata struct {
	pathType PathType
	root     Path
	parent   Path
	element  interface{}
}

func (pm PathMetadata) Type() reflect.Type { return reflect.TypeOf(pm.pathType) }
func (pm PathMetadata) IsZero() bool {
	return pm == PathMetadata{}
}
func (pm PathMetadata) PathType() PathType { return pm.pathType }
func (pm PathMetadata) Parent() Path       { return pm.parent }
func (pm PathMetadata) Root() Path         { return pm.root }
func (pm PathMetadata) IsRoot() bool {
	return pm.Parent() == nil || (pm.PathType() == Delegate && pm.Parent().Metadata().IsRoot())
}
func (pm PathMetadata) Elem() interface{} { return pm.element }
func (pm PathMetadata) Name() string {
	switch pm.pathType {
	case Variable, Property:
		return pm.Elem().(string)
	}
	panic(fmt.Sprintf("name property not available for path type %d, must be accessed with Element()", pm.pathType))
}

// ================================================
// PATH
type Path interface {
	Expression
	Metadata() PathMetadata
	Root() Path
}

type TypedPath[T any] interface {
	// TypedExpression[T]
	Path
}

// -------------------------------------
// NewSimplePath
func NewSimplePathForProperty[T any](value T, propName string, parent Path) SimplePath[T] {
	return NewSimplePath[T](value, NewPathMetadataForProperty(propName, parent))
}
func NewSimplePathForVariable[T any](value T, variableName string) SimplePath[T] {
	return NewSimplePath[T](value, NewPathMetadataForVariable(variableName))
}
func NewSimplePath[T any](value T, pm PathMetadata) SimplePath[T] {
	return SimplePath[T]{
		value: value,
		pm: pm,
	}
}
type SimplePath[T any] struct {
	value T
	pm PathMetadata
}
func (p SimplePath[T]) Type() reflect.Type { return p.pm.Type() }
func (p SimplePath[T]) String() string { return VisitWithDefaultToStringBuilder(p) }
func (p SimplePath[T]) Metadata() PathMetadata { return p.pm }
func (p SimplePath[T]) Root() Path { return p.pm.Root() }

// -------------------------------------
// NewBoolPath
func NewBoolPath(p SimplePath[bool]) BoolPath {
	return BoolPath{
		mixin: p,
	}
}
type BoolPath struct {
	mixin SimplePath[bool] // & BooleanExpression
}
// -- Expression
func (p BoolPath) Type() reflect.Type { return p.mixin.Type() }
func (p BoolPath) String() string { return VisitWithDefaultToStringBuilder(p) }
// -- Path
func (p BoolPath) Metadata() PathMetadata { return p.mixin.Metadata() }
func (p BoolPath) Root() Path { return p.mixin.Root() }
// -- BooleanExpression
func (o BoolPath) As(alias string) BooleanExpression {
	return o.AsPath(NewSimplePathForVariable[bool](false, alias))
}
func (o BoolPath) AsPath(p TypedPath[bool]) BooleanExpression {
	return NewOpAlias(o, p)
}
func (p BoolPath) And(e PredicateExpression) BooleanExpression {
	return NewOpAnd(p, e)
}
func (p BoolPath) Not() BooleanExpression {
	return NewOpNot(p)
}
func (p BoolPath) Or(e PredicateExpression) BooleanExpression {
	return NewOpOr(p, e)
}
func (p BoolPath) IsTrue() BooleanExpression {
	return p.EqValue(true)
}
func (p BoolPath) IsFalse() BooleanExpression {
	return p.EqValue(false)
}
func (p BoolPath) EqValue(v bool) BooleanExpression {
	return p.Eq(NewSimpleConstant[bool](v))
}
func (p BoolPath) Eq(v TypedExpression[bool]) BooleanExpression {
	return NewOpEqual(p, v)
}
func (p BoolPath) NotEqValue(v bool) BooleanExpression {
	return p.NotEq(NewSimpleConstant[bool](v))
}
func (p BoolPath) NotEq(v TypedExpression[bool]) BooleanExpression {
	return p.Eq(v).Not()
}

// -------------------------------------
// NewNumberPath
func NewNumberPath[T numeric](p SimplePath[T]) NumberPath[T] {
	return NumberPath[T]{
		mixin: p,
	}
}
// NumberPath is a basic NumberExpression of numberic type T
type NumberPath[T numeric] struct {
	mixin SimplePath[T]
}
// -- Expression
func (p NumberPath[T]) Type() reflect.Type { return p.mixin.Type() }
func (p NumberPath[T]) String() string { return VisitWithDefaultToStringBuilder(p) }
// -- Path
func (p NumberPath[T]) Metadata() PathMetadata { return p.mixin.Metadata() }
func (p NumberPath[T]) Root() Path { return p.mixin.Root() }
// -- LiteralExpression
func (p NumberPath[T]) StringValue() StringExpression {
	return NewStringOperation(OpStringCast, p)
}
// -- AnyComparableExpression
func (p NumberPath[T]) Asc() Order {
	return NewOrderByDefaultNull[T](OrderAsc, p)
}
func (p NumberPath[T]) Desc() Order {
	return NewOrderByDefaultNull[T](OrderDesc, p)
}
// -- ComparableExpression
func (p NumberPath[T]) BetweenValues(l, r T) BooleanExpression {
	return p.Between(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (p NumberPath[T]) Between(l, r TypedExpression[T]) BooleanExpression {
	return NewOpBetween(p, l, r)
}
func (p NumberPath[T]) NotBetweenValues(l, r T) BooleanExpression {
	return p.NotBetween(NewSimpleConstant[T](l), NewSimpleConstant[T](r))
}
func (p NumberPath[T]) NotBetween(l, r TypedExpression[T]) BooleanExpression {
	return NewOpNotBetween(p, l, r)
}
func (p NumberPath[T]) GTValue(v T) BooleanExpression {
	return p.GT(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) GT(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThan(p, e)
}
func (p NumberPath[T]) GTOrEqValue(v T) BooleanExpression {
	return p.GTOrEq(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) GTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpGreaterThanOrEqual(p, e)
}
func (p NumberPath[T]) LTValue(v T) BooleanExpression {
	return p.LT(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) LT(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThan(p, e)
}
func (p NumberPath[T]) LTOrEqValue(v T) BooleanExpression {
	return p.LTOrEq(NewSimpleConstant[T](v))
}
func (p NumberPath[T]) LTOrEq(e TypedExpression[T]) BooleanExpression {
	return NewOpLessThanOrEqual(p, e)
}
// -- NumberExpression
func (o NumberPath[T]) Abs() NumberExpression[T] {
	return NewNumberOperation[T](OpAbs, o)
}
func (o NumberPath[T]) AddValue(v T) NumberExpression[T] {
	return o.Add(NewSimpleConstant[T](v))
}
func (o NumberPath[T]) Add(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpAddition, o, v)
}
func (o NumberPath[T]) AsPath(p TypedPath[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpAlias, o, p)
}
func (o NumberPath[T]) As(alias string) NumberExpression[T] {
	var defValue T
	return o.AsPath(NewSimplePathForVariable[T](defValue, alias))
}
func (o NumberPath[T]) Ceil() NumberExpression[T] {
	return NewNumberOperation[T](OpCeiling, o)
}
func (o NumberPath[T]) DivideValue(v T) NumberExpression[T] {
	return o.Divide(NewSimpleConstant[T](v))
}
func (o NumberPath[T]) Divide(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpDivision, o, v)
}
func (o NumberPath[T]) EqValue(v T) BooleanExpression {
	return o.Eq(NewSimpleConstant[T](v))
}
func (o NumberPath[T]) Eq(v TypedExpression[T]) BooleanExpression {
	return NewOpEqual(o, v)
}
func (o NumberPath[T]) Floor() NumberExpression[T] {
	return NewNumberOperation[T](OpFloor, o)
}
func (o NumberPath[T]) ModValue(v T) NumberExpression[T] {
	return o.Mod(NewSimpleConstant[T](v))
}
func (o NumberPath[T]) Mod(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpModulo, o, v)
}
func (o NumberPath[T]) MultiplyValue(v T) NumberExpression[T] {
	return o.Multiply(NewSimpleConstant[T](v))
}
func (o NumberPath[T]) Multiply(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpMultiplication, o, v)
}
func (o NumberPath[T]) Negate() NumberExpression[T] {
	return NewNumberOperation[T](OpNegate, o)
}
func (o NumberPath[T]) Round() NumberExpression[T] {
	return NewNumberOperation[T](OpRound, o)
}
func (o NumberPath[T]) Sqrt() NumberExpression[T] {
	return NewNumberOperation[T](OpSquareRoot, o)
}
func (o NumberPath[T]) SubtractValue(v T) NumberExpression[T] {
	return o.Subtract(NewSimpleConstant[T](v))
}
func (o NumberPath[T]) Subtract(v TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpSubtraction, o, v)
}
func (o NumberPath[T]) InValues(v ...T) NumberExpression[T] {
	return o.In(NewSimpleConstant[[]T](v))
}
func (o NumberPath[T]) In(v ...TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpIn, o, NewSet[T](v...))
}
func (o NumberPath[T]) NotInValues(v ...T) NumberExpression[T] {
	return o.NotIn(NewSimpleConstant[[]T](v))
}
func (o NumberPath[T]) NotIn(v ...TypedExpression[T]) NumberExpression[T] {
	return NewNumberOperation[T](OpNotIn, o, NewSet[T](v...))
}

// -------------------------------------
// NewStringPath is a basic StringExpression path
func NewStringPath(p SimplePath[string]) StringPath {
	return StringPath{
		mixin: p,
	}
}
type StringPath struct {
	mixin SimplePath[string]
}
// -- Expression
func (o StringPath) Type() reflect.Type { return o.mixin.Type() }
func (o StringPath) String() string {
	return o.mixin.String()
}

// -- AnyComparableExpression
func (o StringPath) Asc() Order {
	return NewOrderByDefaultNull[string](OrderAsc, o)
}
func (o StringPath) Desc() Order {
	return NewOrderByDefaultNull[string](OrderDesc, o)
}

// -- ComparableExpression
func (o StringPath) BetweenValues(l, r string) BooleanExpression {
	return o.Between(NewSimpleConstant[string](l), NewSimpleConstant[string](r))
}
func (o StringPath) Between(l, r TypedExpression[string]) BooleanExpression {
	return NewOpBetween(o, l, r)
}
func (o StringPath) NotBetweenValues(l, r string) BooleanExpression {
	return o.NotBetween(NewSimpleConstant[string](l), NewSimpleConstant[string](r))
}
func (o StringPath) NotBetween(l, r TypedExpression[string]) BooleanExpression {
	return NewOpNotBetween(o, l, r)
}
func (o StringPath) GTValue(v string) BooleanExpression {
	return o.GT(NewSimpleConstant[string](v))
}
func (o StringPath) GT(v TypedExpression[string]) BooleanExpression {
	return NewOpGreaterThan(o, v)
}
func (o StringPath) GTOrEqValue(v string) BooleanExpression {
	return o.GTOrEq(NewSimpleConstant[string](v))
}
func (o StringPath) GTOrEq(v TypedExpression[string]) BooleanExpression {
	return NewOpGreaterThanOrEqual(o, v)
}
func (o StringPath) LTValue(v string) BooleanExpression {
	return o.LT(NewSimpleConstant[string](v))
}
func (o StringPath) LT(v TypedExpression[string]) BooleanExpression {
	return NewOpLessThan(o, v)
}
func (o StringPath) LTOrEqValue(v string) BooleanExpression {
	return o.LTOrEq(NewSimpleConstant[string](v))
}
func (o StringPath) LTOrEq(v TypedExpression[string]) BooleanExpression {
	return NewOpLessThanOrEqual(o, v)
}

// -- LiteralExpression
func (o StringPath) StringValue() StringExpression {
	return o
}

// -- StringExpression
func (o StringPath) As(alias TypedPath[string]) StringExpression {
	return NewStringOperation(OpAlias, o, alias)
}
func (o StringPath) Alias(alias string) StringExpression {
	return o.As(NewSimplePathForVariable[string]("", alias))
}
func (o StringPath) AppendValue(v string) StringExpression {
	return o.Append(NewSimpleConstant[string](v))
}
func (o StringPath) Append(v TypedExpression[string]) StringExpression {
	return NewStringOperation(OpStringConcat, o, v)
}
func (o StringPath) CharAtValue(idx int) TypedExpression[rune] {
	return o.CharAt(NewSimpleConstant[int](idx))
}
func (o StringPath) CharAt(idx TypedExpression[int]) TypedExpression[rune] {
	return NewComparableOperation[rune](OpCharAt, o, idx)
}
func (o StringPath) ConcatValue(v string) StringExpression {
	return o.AppendValue(v)
}
func (o StringPath) Concat(v TypedExpression[string]) StringExpression {
	return o.Append(v)
}
func (o StringPath) ContainsValue(v string) BooleanExpression {
	return o.Contains(NewSimpleConstant[string](v))
}
func (o StringPath) Contains(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringContains, o, v)
}
func (o StringPath) ContainsFoldValue(v string) BooleanExpression {
	return o.ContainsFold(NewSimpleConstant[string](v))
}
func (o StringPath) ContainsFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringContainsFold, o, v)
}
func (o StringPath) EqualsFoldValue(v string) BooleanExpression {
	return o.EqualsFold(NewSimpleConstant[string](v))
}
func (o StringPath) EqualsFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpEqualsFold, o, v)
}
func (o StringPath) HasPrefixValue(v string) BooleanExpression {
	return o.HasPrefix(NewSimpleConstant[string](v))
}
func (o StringPath) HasPrefix(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasPrefix, o, v)
}
func (o StringPath) HasPrefixFoldValue(v string) BooleanExpression {
	return o.HasPrefixFold(NewSimpleConstant[string](v))
}
func (o StringPath) HasPrefixFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasPrefixFold, o, v)
}
func (o StringPath) HasSuffixValue(v string) BooleanExpression {
	return o.HasSuffix(NewSimpleConstant[string](v))
}
func (o StringPath) HasSuffix(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasSuffix, o, v)
}
func (o StringPath) HasSuffixFoldValue(v string) BooleanExpression {
	return o.HasSuffixFold(NewSimpleConstant[string](v))
}
func (o StringPath) HasSuffixFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpHasSuffixFold, o, v)
}
func (o StringPath) IndexOfValue(v string) NumberExpression[int] {
	return o.IndexOf(NewSimpleConstant[string](v))
}
func (o StringPath) IndexOf(v TypedExpression[string]) NumberExpression[int] {
	return NewNumberOperation[int](OpIndexOf, o, v)
}
func (o StringPath) IndexOfNValue(v string, n int) NumberExpression[int] {
	return o.IndexOfN(NewSimpleConstant[string](v), n)
}
func (o StringPath) IndexOfN(v TypedExpression[string], n int) NumberExpression[int] {
	return NewNumberOperation[int](OpIndexOfN, o, v, NewSimpleConstant[int](n))
}
func (o StringPath) IsEmpty() BooleanExpression {
	return NewBooleanOperation(OpStringIsEmpty, o)
}
func (o StringPath) IsNotEmpty() BooleanExpression {
	return o.IsEmpty().Not()
}
func (o StringPath) Len() NumberExpression[int] {
	return NewNumberOperation[int](OpStringLength, o)
}
func (o StringPath) LikeValue(v string) BooleanExpression {
	return o.Like(NewSimpleConstant[string](v))
}
func (o StringPath) Like(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringLike, o, v)
}
func (o StringPath) LikeFoldValue(v string) BooleanExpression {
	return o.LikeFold(NewSimpleConstant[string](v))
}
func (o StringPath) LikeFold(v TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringLikeFold, o, v)
}
func (o StringPath) LikeEscapeValue(v string, escape rune) BooleanExpression {
	return o.LikeEscape(NewSimpleConstant[string](v), escape)
}
func (o StringPath) LikeEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return NewBooleanOperation(OpStringLikeEscape, o, v, NewSimpleConstant[rune](escape))
}
func (o StringPath) LikeFoldEscapeValue(v string, escape rune) BooleanExpression {
	return o.LikeFoldEscape(NewSimpleConstant[string](v), escape)
}
func (o StringPath) LikeFoldEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return NewBooleanOperation(OpStringLikeFoldEscape, o, v, NewSimpleConstant[rune](escape))
}
func (o StringPath) LocateValue(v string) NumberExpression[int] {
	return o.Locate(NewSimpleConstant[string](v))
}
func (o StringPath) Locate(v TypedExpression[string]) NumberExpression[int] {
	return NewNumberOperation[int](OpStringLocate, v)
}
func (o StringPath) LocateFromValues(v string, start int) NumberExpression[int] {
	return o.LocateFromValue(NewSimpleConstant[string](v), start)
}
func (o StringPath) LocateFromValue(v TypedExpression[string], start int) NumberExpression[int] {
	return o.LocateFrom(v, NewSimpleConstant[int](start))
}
func (o StringPath) LocateFrom(v TypedExpression[string], start TypedExpression[int]) NumberExpression[int] {
	return NewNumberOperation[int](OpStringLocate2, v)
}
func (o StringPath) Lower() StringExpression {
	return NewStringOperation(OpStringLower, o)
}
func (o StringPath) MatchesValue(regex regexp.Regexp) BooleanExpression {
	return o.Matches(NewSimpleConstant[string](regex.String()))
}
func (o StringPath) Matches(regex TypedExpression[string]) BooleanExpression {
	return NewBooleanOperation(OpStringMatches, o, regex)
}
func (o StringPath) NotEqFoldValue(v string) BooleanExpression {
	return o.NotEqFold(NewSimpleConstant[string](v))
}
func (o StringPath) NotEqFold(v TypedExpression[string]) BooleanExpression {
	return o.EqualsFold(v).Not()
}

func (o StringPath) NotLikeValue(v string) BooleanExpression {
	return o.NotLike(NewSimpleConstant[string](v))
}
func (o StringPath) NotLike(v TypedExpression[string]) BooleanExpression {
	return o.Like(v).Not()
}
func (o StringPath) NotLikeFoldValue(v string) BooleanExpression {
	return o.NotLikeFold(NewSimpleConstant[string](v))
}
func (o StringPath) NotLikeFold(v TypedExpression[string]) BooleanExpression {
	return o.LikeFold(v).Not()
}
func (o StringPath) NotLikeEscapeValue(v string, escape rune) BooleanExpression {
	return o.NotLikeEscape(NewSimpleConstant[string](v), escape)
}
func (o StringPath) NotLikeEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return o.LikeEscape(v, escape).Not()
}
func (o StringPath) NotLikeFoldEscapeValue(v string, escape rune) BooleanExpression {
	return o.NotLikeFoldEscape(NewSimpleConstant[string](v), escape)
}
func (o StringPath) NotLikeFoldEscape(v TypedExpression[string], escape rune) BooleanExpression {
	return o.LikeFoldEscape(v, escape).Not()
}
func (o StringPath) PrependValue(v string) StringExpression {
	return o.Prepend(NewSimpleConstant[string](v))
}
func (o StringPath) Prepend(v TypedExpression[string]) StringExpression {
	return NewStringOperation(OpStringConcat, o, v)
}
func (o StringPath) SubstringStartValue(begin int) StringExpression {
	return o.SubstringStart(NewSimpleConstant[int](begin))
}
func (o StringPath) SubstringStart(begin TypedExpression[int]) StringExpression {
	return NewStringOperation(OpStringSubstring, o, begin)
}
func (o StringPath) SubstringStartValueEnd(begin int, end TypedExpression[int]) StringExpression {
	return o.SubstringStartEnd(NewSimpleConstant[int](begin), end)
}
func (o StringPath) SubstringStartEndValue(begin TypedExpression[int], end int) StringExpression {
	return o.SubstringStartEnd(begin, NewSimpleConstant[int](end))
}
func (o StringPath) SubstringStartAndEndValue(begin, end int) StringExpression {
	return o.SubstringStartEnd(NewSimpleConstant[int](begin), NewSimpleConstant[int](end))
}
func (o StringPath) SubstringStartEnd(begin, end TypedExpression[int]) StringExpression {
	return NewStringOperation(OpStringSubstring2, o, begin, end)
}
func (o StringPath) Trim() StringExpression {
	return NewStringOperation(OpStringTrim, o)
}
func (o StringPath) Upper() StringExpression {
	return NewStringOperation(OpStringToUpper, o)
}

// -------------------------------------
// NewEntityPath is a basic Table path
func NewEntityPath(p Path[T]) EntityPath {
	return EntityPath{
		mixin: p,
	}
}
type EntityPath[T any] struct {
	mixin Path[T]
}
// -- Expression
func (o StringPath) Type() reflect.Type { return o.mixin.Type() }
func (o StringPath) String() string {
	return o.mixin.String()
}